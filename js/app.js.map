{"version":3,"file":"app.js","sources":["../../__babelHelpers__","controllers/base.js","views/navigation-menu.jsx","views/base-view.jsx","views/user-login.jsx","controllers/users.js","views/services-list-item.jsx","views/services-list.jsx","views/services.jsx","controllers/services.js","views/services/camera.jsx","views/services/light.jsx","views/services/default.jsx","views/service.jsx","controllers/service.js","views/tag-list.jsx","views/service-tags.jsx","controllers/service-tags.js","views/themes-list-item.jsx","views/themes.jsx","views/themes-new.jsx","controllers/themes.js","views/dev/camera-latest-image.jsx","controllers/dev.js","lib/foxbox/common/event-dispatcher.js","lib/foxbox/settings.js","lib/foxbox/common/defer.js","lib/foxbox/db.js","lib/foxbox/common/sequential-timer.js","lib/foxbox/box-link.js","lib/foxbox/network.js","lib/foxbox/recipes.js","lib/foxbox/webpush.js","lib/foxbox/services/base.js","lib/foxbox/services/ip-camera.js","lib/foxbox/services/light.js","lib/foxbox/services/door-lock.js","lib/foxbox/services/motion-sensor.js","lib/foxbox/services.js","lib/foxbox/api.js","lib/foxbox/foxbox.js","controllers/main.js","app.js"],"sourcesContent":["var babelHelpers = {};\nexport var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nexport var jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nexport var asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nexport var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexport var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexport var defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nexport var defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nexport var defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nexport var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexport var get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nexport var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nexport var _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nexport var interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nexport var interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nexport var newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nexport var objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nexport var objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nexport var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nexport var selfGlobal = typeof global === \"undefined\" ? self : global;\n\nexport var set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nexport var slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexport var slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nexport var taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nexport var taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nexport var temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nexport var temporalUndefined = {};\n\nexport var toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nexport var toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nbabelHelpers;\n\nexport { _typeof as typeof, _extends as extends, _instanceof as instanceof }","export default class BaseController {\n  constructor(properties) {\n    Object.assign(this, properties || {});\n  }\n\n  main() {\n    throw new Error('Not implemented!');\n  }\n}\n","import React from 'components/react';\n\nexport default class NavigationMenu extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.foxbox = props.foxbox;\n  }\n\n  shouldComponentUpdate() {\n    // We never need to update this component as it is being recreated each time\n    // the route changes.\n    return false;\n  }\n\n  handleOnClick() {\n    this.foxbox.logout();\n  }\n\n  render() {\n    const route = location.hash.substr(1).split('/').shift();\n    let menuNodes = [\n      {\n        id: 'services',\n        label: 'Home',\n      },\n      {\n        id: 'themes',\n        label: 'Themes',\n      },\n      {\n        id: 'mr-fox',\n        label: 'Mr. Fox',\n      },\n    ].map((menu) => {\n      let className = 'navigation-menu__item';\n      if (route === menu.id) {\n        className += ' navigation-menu__item--active';\n      }\n\n      return (\n        <li key={menu.id} className={className}>\n          <a href={`#${menu.id}`}\n             className=\"navigation-menu__item-link\">\n            {menu.label}\n          </a>\n        </li>\n      );\n    });\n\n    return (\n      <ul className=\"navigation-menu\">\n        {menuNodes}\n        <li className=\"navigation-menu__item\">\n          <a href=\"#users/login\"\n             className=\"navigation-menu__item-link user-logout-button\"\n             onClick={this.handleOnClick.bind(this)}>\n            Log out\n          </a>\n        </li>\n      </ul>\n    );\n  }\n}\n\nNavigationMenu.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport NavigationMenu from './navigation-menu';\n\nexport default class BaseView extends React.Component {\n  renderHeader(title, cssClass) {\n    let className = 'app-view__header';\n    if (cssClass) {\n      className += ` ${cssClass}`;\n    }\n\n    return (\n      <header className={className}>\n        <h1>{title}</h1>\n      </header>\n    );\n  }\n\n  renderFooter() {\n    return (\n      <footer className=\"app-view__footer\">\n        <NavigationMenu foxbox={this.props.foxbox}/>\n      </footer>\n    );\n  }\n\n  renderBody() {\n    return null;\n  }\n\n  render() {\n    return (\n      <div className=\"app-view\">\n        {this.renderHeader()}\n        <section className=\"app-view__body\">{this.renderBody()}</section>\n        {this.renderFooter()}\n      </div>\n    );\n  }\n}\n\nBaseView.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\n\nexport default class UserLogin extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      boxes: props.foxbox.boxes,\n      selectedBox: null,\n      loginEnabled: props.foxbox.online,\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.onBoxOnline = this.onBoxOnline.bind(this);\n    this.onBoxDiscovery = this.onBoxDiscovery.bind(this);\n    this.onSelectChange = this.onSelectChange.bind(this);\n    this.onFormSubmit = this.onFormSubmit.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.on('online', this.onBoxOnline);\n    this.foxbox.on('discovery', this.onBoxDiscovery);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.off('online', this.onBoxOnline);\n    this.foxbox.off('discovery', this.onBoxDiscovery);\n  }\n\n  onSelectChange(evt) {\n    const selectedBox = evt.target.selectedIndex;\n\n    this.setState({ selectedBox });\n    this.foxbox.selectBox(selectedBox);\n  }\n\n  onFormSubmit(evt) {\n    evt.preventDefault(); // Avoid redirection to /?.\n\n    this.foxbox.login();\n  }\n\n  onBoxOnline(loginEnabled) {\n    this.setState({ loginEnabled });\n  }\n\n  onBoxDiscovery() {\n    this.setState({ boxes: this.foxbox.boxes });\n  }\n\n  renderHeader() {\n    return super.renderHeader('Project Link', 'app-view__header--white');\n  }\n\n  renderFooter() {\n    return null;\n  }\n\n  renderBody() {\n    let boxNodes = null;\n\n    if (this.state.boxes.length > 1) {\n      let selectedBox = this.state.selectedBox || 0;\n      const optionNodes = this.state.boxes.map((box, index) => {\n        if (box.client === this.foxbox.client) {\n          selectedBox = index;\n        }\n\n        return (\n          <option key={box.client} value={index}>{box.client}</option>\n        );\n      });\n\n      boxNodes = (<select\n        className=\"user-login__box-selector\"\n        value={selectedBox}\n        onChange={this.onSelectChange}>{optionNodes}</select>);\n    }\n\n    return (\n      <form className=\"app-view__fill-body user-login\"\n            onSubmit={this.onFormSubmit}>\n        <img className=\"user-login__logo\" src=\"img/icon.svg\"/>\n        {boxNodes}\n        <button className=\"user-login__login-button\"\n                disabled={!this.state.loginEnabled}>Connect to your box\n        </button>\n      </form>\n    );\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport UserLogin from '../views/user-login';\n\nconst ALLOWED_ACTIONS = ['login', 'logout'];\nconst DEFAULT_ACTION = ALLOWED_ACTIONS[0];\n\nexport default class UsersController extends BaseController {\n  main(action = DEFAULT_ACTION) {\n    if (!ALLOWED_ACTIONS.includes(action)) {\n      console.error(\n        `Bad users route: \"${action}\". Falling back to ${DEFAULT_ACTION}.`\n      );\n      action = DEFAULT_ACTION;\n    }\n\n    switch (action) {\n      case 'login':\n        this.login();\n        break;\n\n      case 'logout':\n        this.logout();\n        break;\n    }\n  }\n\n  login() {\n    ReactDOM.render(\n      React.createElement(UserLogin, { foxbox: this.foxbox }), this.mountNode\n    );\n  }\n\n  logout() {\n    this.foxbox.logout();\n\n    // Once logged out, we redirect to the login page.\n    location.hash = '#users/login';\n  }\n}\n","import React from 'components/react';\n\nexport default class ServicesListItem extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      available: false,\n      on: true,\n      locked: true,\n      motionDetected: false,\n    };\n\n    this.service = props.service;\n    this.foxbox = props.foxbox;\n\n    this.onMotion = this.onMotion.bind(this);\n  }\n\n  componentDidMount() {\n    switch (this.service.type) {\n      case 'light':\n        this.service.isAvailable()\n          .then((available) => {\n            this.setState({ available });\n          })\n          .catch(console.error.bind(console));\n\n        this.service.isOn()\n          .then((on) => {\n            this.setState({ on });\n          })\n          .catch(console.error.bind(console));\n        break;\n      case 'motion-sensor':\n        this.service.isMotionDetected()\n          .then(this.onMotion);\n        this.service.watch('motion', this.onMotion);\n        break;\n      case 'door-lock':\n        this.service.isLocked()\n          .then((locked) => {\n            this.setState({ locked });\n          })\n          .catch((error) => {\n            console.error('Can not retrieve door lock status: %o', error);\n          });\n        break;\n    }\n  }\n\n  componentWillUnmount() {\n    switch (this.service.type) {\n      case 'motion-sensor':\n        this.service.unwatch('motion', this.onMotion);\n        break;\n    }\n  }\n\n  handleLightOnChange(evt) {\n    const on = evt.target.checked;\n\n    // Optimistic update.\n    this.setState({ on });\n\n    this.service.turn(on)\n      .catch((error) => {\n        // Revert back to the previous value.\n        this.setState({ on: !on });\n        console.error(error);\n      });\n  }\n\n  onDoorLockUnlock(evt) {\n    const locked = evt.target.checked;\n\n    this.setState({ locked });\n\n    this.service.lockUnlock(locked)\n      .catch((error) => {\n        // Revert back to the previous value.\n        this.setState({ locked: !locked });\n        console.error('Could not change door lock status: %o', error);\n      });\n  }\n\n  onMotion(motionDetected) {\n    this.setState({ motionDetected });\n  }\n\n  /**\n   * Convert colours from xy space to RGB.\n   * See details at:\n   * http://www.developers.meethue.com/documentation/color-conversions-rgb-xy\n   *\n   * @return {string}\n   */\n  getBulbColour() {\n    const hue = /* this.service.hue */ 1;\n    const sat = /* this.service.sat */ 1;\n    const val = /* this.service.val */ 1;\n    const h = hue;\n    const s = Math.round(sat * 100);\n    const l = val;\n\n    // We set the luminosity to 50% and use the brightness as the opacity. The\n    // brighter, the more opaque. Pale shades get transparent.\n    return `hsla(${h},${s}%,50%,${l})`;\n  }\n\n  renderLightService() {\n    let isConnected = this.state.available;\n\n    let serviceType = 'Light';\n    let icon = 'light';\n\n    if (this.service.model !== undefined) {\n      switch (this.service.model) {\n        case 'BSB002':\n          icon = 'bridge_v2';\n          break;\n\n        case 'LCT001':\n        case 'LCT007':\n        case 'LCT010':\n        case 'LTW010':\n        case 'LWB004':\n        case 'LWB006':\n          icon = 'white_and_color_e27_b22';\n          break;\n\n        case 'LWB010':\n        case 'LWB014':\n          icon = 'white_e27_b22';\n          break;\n\n        case 'LCT002':\n        case 'LCT011':\n        case 'LTW011':\n        case 'LWB005':\n        case 'LWB011':\n          icon = 'br30';\n          break;\n\n        case 'LCT003':\n          icon = 'gu10_par16';\n          break;\n\n        case 'LST001':\n        case 'LST002':\n          icon = 'lightstrip';\n          break;\n\n        case 'LLC006':\n        case 'LLC010':\n          icon = 'iris';\n          break;\n\n        case 'LLC005':\n        case 'LLC011':\n        case 'LLC012':\n        case 'LLC007':\n          icon = 'bloom';\n          break;\n\n        case 'LLC014':\n          icon = 'aura';\n          break;\n\n        case 'LLC013':\n          icon = 'storylight';\n          break;\n\n        case 'LLC020':\n          icon = 'go';\n          break;\n\n        case 'HBL001':\n        case 'HBL002':\n        case 'HBL003':\n          icon = 'beyond_ceiling_pendant_table';\n          break;\n\n        case 'HIL001':\n        case 'HIL002':\n          icon = 'impulse';\n          break;\n\n        case 'HEL001':\n        case 'HEL002':\n          icon = 'entity';\n          break;\n\n        case 'HML001':\n        case 'HML002':\n        case 'HML003':\n        case 'HML004':\n        case 'HML005':\n        case 'HML006':\n          icon = 'phoenix_ceiling_pendant_table_wall';\n          break;\n\n        case 'HML007':\n          icon = 'phoenix_recessed_spot';\n          break;\n\n        case 'SWT001':\n          icon = 'tap';\n          break;\n\n        case 'RWL021':\n          icon = 'hds';\n          break;\n      }\n    }\n\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon={icon}\n          data-connected={isConnected}>\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          {serviceType}\n          {serviceNameNode}\n        </a>\n        <div className=\"service-list__item-color-picker\"\n             style={{ background: this.getBulbColour() }}>\n        </div>\n        <label>\n          <input className=\"service-list__on-off-toggle\" type=\"checkbox\"\n                 checked={this.state.on} disabled={!isConnected}\n                 onChange={this.handleLightOnChange.bind(this)}/>\n        </label>\n      </li>\n    );\n  }\n\n  renderDoorLock() {\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon=\"door-lock\">\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          Door Lock\n          {serviceNameNode}\n        </a>\n        <label>\n          <input className=\"service-list__on-off-toggle\" type=\"checkbox\"\n                 checked={this.state.locked}\n                 onChange={this.onDoorLockUnlock.bind(this)}/>\n        </label>\n      </li>\n    );\n  }\n\n  renderMotionSensor() {\n    const serviceName = this.getServiceName();\n    const motionSensorNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    let motionSensorClassName = 'service-list__item motion-sensor-item';\n    if (this.state.motionDetected) {\n      motionSensorClassName += ' motion-sensor-item--motion-detected';\n    }\n\n    return (\n      <li className={motionSensorClassName}>\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          Motion Sensor\n          {motionSensorNameNode}\n        </a>\n      </li>\n    );\n  }\n\n  renderGenericService(type = 'Unknown service', icon = 'unknown') {\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon={icon} data-connected=\"true\">\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          {type}\n          {serviceNameNode}\n        </a>\n      </li>\n    );\n  }\n\n  render() {\n    switch (this.service.type) {\n      case 'door-lock':\n        return this.renderDoorLock();\n      case 'ip-camera':\n        return this.renderGenericService('Camera', 'ip-camera');\n      case 'light':\n        return this.renderLightService();\n      case 'motion-sensor':\n        return this.renderMotionSensor();\n      default:\n        return this.renderGenericService();\n    }\n  }\n\n  getServiceName() {\n    // If service has tags, let's use them as service identifier.\n    return this.service.getTags().join(', ') || this.service.name;\n  }\n}\n\nServicesListItem.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport ServicesListItem from './services-list-item';\n\nexport default class ServicesList extends React.Component {\n  render() {\n    const knownServices = this.props.services.filter(\n      (service) => service.type !== 'unknown'\n    );\n\n    const serviceNodes = knownServices.map((service) => (\n        <ServicesListItem\n          key={service.id}\n          service={service}\n          foxbox={this.props.foxbox}/>\n      )\n    );\n\n    return (\n      <ul className=\"service-list\">{serviceNodes}</ul>\n    );\n  }\n}\n\nServicesList.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  services: React.PropTypes.array.isRequired,\n};\n","import React from 'components/react';\n\nimport ServicesListView from './services-list';\nimport BaseView from './base-view';\n\nexport default class Services extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      services: [],\n\n      title: '',\n      body: '',\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.updateServiceList = this.updateServiceList.bind(this);\n    this.updateServiceState = this.updateServiceState.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateServiceList();\n\n    this.foxbox.services.togglePolling(true);\n\n    this.foxbox.services.on('services-changed', this.updateServiceList);\n    this.foxbox.services.on('service-changed', this.updateServiceState);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.togglePolling(false);\n\n    this.foxbox.services.off('services-changed', this.updateServiceList);\n    this.foxbox.services.off('service-changed', this.updateServiceState);\n  }\n\n  updateServiceList() {\n    this.foxbox.services.getAll()\n      .then((services) => this.setState({ services }))\n      .catch((error) => {\n        console.error('Could not update service list: %o', error);\n      });\n  }\n\n  updateServiceState(state) {\n    // Find the index of the service which state has changed.\n    const serviceId = this.state.services.findIndex(\n      (service) => service.id === state.id\n    );\n    const services = this.state.services;\n\n    // Update the new state.\n    services[serviceId] = state;\n    this.setState({ services });\n  }\n\n  renderHeader() {\n    return super.renderHeader('My Home');\n  }\n\n  renderBody() {\n    return (\n      <div className=\"app-view__fill-body\">\n        <h2>General</h2>\n        <ServicesListView services={this.state.services} foxbox={this.foxbox} />\n      </div>\n    );\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport Services from '../views/services';\n\nexport default class ServicesController extends BaseController {\n  main() {\n    ReactDOM.render(React.createElement(Services, {\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class CameraService extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      hasPreview: false,\n      hasPreviousSnapshot: false,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n  }\n\n  /**\n   * Takes camera snapshot and displays it to the user.\n   *\n   * @private\n   */\n  takeSnapshot() {\n    this.service.takeSnapshot()\n      .then((image) => {\n        const previousSnapshot = this.refs.snapshotPreview.src;\n\n        const newState = {\n          hasPreview: true,\n          hasPreviousSnapshot: false,\n        };\n\n        this.refs.snapshotPreview.src = URL.createObjectURL(image);\n\n        if (previousSnapshot) {\n          newState.hasPreviousSnapshot = true;\n\n          if (this.refs.previousSnapshot.src) {\n            URL.revokeObjectURL(this.refs.previousSnapshot.src);\n          }\n\n          this.refs.previousSnapshot.src = previousSnapshot;\n        }\n\n        this.setState(newState);\n      })\n      .catch((error) => {\n        console.error('Error occurred while making a snapshot: ', error);\n      });\n  }\n\n  render() {\n    let cameraControlsClass = 'app-view__fill-body camera-controls';\n\n    if (this.state.hasPreview) {\n      cameraControlsClass += ' camera-controls--has-preview';\n    }\n\n    if (this.state.hasPreviousSnapshot) {\n      cameraControlsClass += ' camera-controls--has-previous-snapshot';\n    }\n\n    return (\n      <div className={cameraControlsClass}>\n        <img ref=\"snapshotPreview\"\n             alt={'Snapshot preview'} className=\"camera-controls__preview\" />\n        <div className=\"camera-controls__empty-preview\">\n          <p>Preview is not available.</p>\n          <p>Touch button to take a snapshot!</p>\n        </div>\n        <section className=\"camera-controls__snapshot-tools\">\n          <button className=\"camera-controls__snapshot-btn\" type=\"button\"\n                  title=\"Take a snapshot\"\n                  onClick={this.takeSnapshot.bind(this)}>\n          </button>\n          <img ref=\"previousSnapshot\"\n               className=\"camera-controls__previous-snapshot\" />\n        </section>\n      </div>\n    );\n  }\n}\n\nCameraService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nexport default class LightService extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: props.service.name,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.service.id) {\n      return;\n    }\n\n    this.service = service;\n    this.setState({ name: service.name });\n  }\n\n  render() {\n    return (\n      <div className=\"app-view__fill-body default-service__body\">\n        <p className=\"default-service__notice\">\n          Oops, there are no settings available for this service.\n        </p>\n      </div>\n    );\n  }\n}\n\nLightService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nexport default class Service extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: props.service.name,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.service.id) {\n      return;\n    }\n\n    this.service = service;\n    this.setState({ name: service.name });\n  }\n\n  render() {\n    return (\n      <div className=\"app-view__fill-body default-service__body\">\n        <p className=\"default-service__notice\">\n          Oops, there are no settings available for this service.\n        </p>\n      </div>\n    );\n  }\n}\n\nService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport CameraServiceView from './services/camera';\nimport LightServiceView from './services/light';\nimport DefaultServiceView from './services/default';\n\nexport default class Service extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      service: null,\n    };\n\n    this.foxbox = props.foxbox;\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service });\n      })\n      .catch((error) => {\n        console.error('Error occurred while retrieving service: ', error);\n      });\n  }\n\n  renderHeader() {\n    if (!this.state.service) {\n      return super.renderHeader('Unknown Service');\n    }\n\n    const serviceName = this.state.service.name ?\n      this.state.service.name :\n      'Unknown Service';\n\n    return (\n      <header className=\"app-view__header\">\n        <h1>{serviceName}</h1>\n        <a href={`#services/${this.state.service.id}/tags`}\n           title=\"Edit tags\"\n           className=\"service__edit-tags-link\">\n          <img className=\"app-view__action-icon\"\n               src=\"css/icons/tag.svg\"\n               alt=\"Edit tags\"/>\n        </a>\n      </header>\n    );\n  }\n\n  renderBody() {\n    if (!this.state.service) {\n      return null;\n    }\n\n    switch (this.state.service.type) {\n      case 'ip-camera':\n        return (<CameraServiceView service={this.state.service}\n                                   foxbox={this.foxbox}/>);\n      case 'light':\n        return (<LightServiceView service={this.state.service}\n                                  foxbox={this.foxbox}/>);\n      default:\n        return (<DefaultServiceView service={this.state.service}\n                                    foxbox={this.foxbox}/>);\n    }\n  }\n}\n\nService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport Service from '../views/service';\n\nexport default class ServiceController extends BaseController {\n  main(id) {\n    ReactDOM.render(React.createElement(Service, {\n      id,\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class TagList extends React.Component {\n  render() {\n    let tagNodes = this.props.tags.map((tag) => (\n      <li key={tag} className=\"tag-list__item\">\n        {tag}\n        <button className=\"tag-list__item-remove\"\n                type=\"button\"\n                onClick={this.props.onRemoveTag.bind(null, tag)}\n                title=\"Remove tag\"></button>\n      </li>\n    ));\n\n    return (\n      <ul className=\"tag-list\">{tagNodes}</ul>\n    );\n  }\n}\n\nTagList.propTypes = {\n  tags: React.PropTypes.array.isRequired,\n  onRemoveTag: React.PropTypes.func.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport TagList from './tag-list';\n\nexport default class ServiceTags extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = { service: null, tags: [] };\n    this.foxbox = props.foxbox;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service, tags: service.getTags() });\n      })\n      .catch((error) => {\n        console.error('Error occurred while retrieving service: ', error);\n      });\n\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.props.id) {\n      return;\n    }\n\n    this.setState({ service, tags: service.getTags() });\n  }\n\n  onAddTag() {\n    const service = this.state.service;\n    if (!service) {\n      return;\n    }\n\n    const tag = (prompt('Enter new tag name') || '').trim();\n    if (!tag) {\n      return;\n    }\n\n    service.addTag(tag)\n      .catch((err) => {\n        // Restore actual tag list if server failed to add tag.\n        console.error(`Could not add the tag \"${tag}\": %o`, err);\n        this.setState({ tags: service.getTags() });\n      });\n\n    this.setState({ tags: service.getTags() });\n  }\n\n  onRemoveTag(tag) {\n    const service = this.state.service;\n\n    service.removeTag(tag)\n      .catch((err) => {\n        // Restore actual tag list if server failed to remove tag.\n        console.error(`Could not remove the tag \"${tag}\": %o`, err);\n        this.setState({ tags: service.getTags() });\n      });\n\n    this.setState({ tags: service.getTags() });\n  }\n\n  renderHeader() {\n    const service = this.state.service;\n    return super.renderHeader(\n      service && service.name ?\n        service.name :\n        'Unknown Service'\n    );\n  }\n\n  renderBody() {\n    return (\n      <div className=\"app-view__fill-body\">\n        <h2>Tags</h2>\n        <TagList tags={this.state.tags}\n                 onRemoveTag={this.onRemoveTag.bind(this)} />\n        <button className=\"add-tag-button\" type=\"button\"\n                onClick={this.onAddTag.bind(this)}>\n          Create a new tag\n        </button>\n      </div>\n    );\n  }\n}\n\nServiceTags.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport ServiceTagsView from '../views/service-tags';\n\nexport default class ServiceTagsController extends BaseController {\n  main(id) {\n    ReactDOM.render(React.createElement(ServiceTagsView, {\n      id,\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class ThemesListItem extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      enabled: props.theme.enabled,\n    };\n\n    this.foxbox = props.foxbox;\n    this.handleOnChange = this.handleOnChange.bind(this);\n    this.handleOnDelete = this.handleOnDelete.bind(this);\n  }\n\n  /**\n   * Activate or deactivate a recipe.\n   *\n   * @param {SyntheticEvent} evt\n   */\n  handleOnChange(evt) {\n    const enabled = evt.target.checked;\n\n    this.setState({ enabled }); // Optimistic update.\n\n    this.foxbox.recipes.toggle(this.props.theme, enabled)\n      .catch((error) => {\n        this.setState({ enabled: !enabled }); // Revert back to previous value.\n        console.error(error);\n      });\n  }\n\n  /**\n   * Delete a recipe.\n   */\n  handleOnDelete() {\n    this.foxbox.recipes.remove(this.props.theme)\n      .then(() => {\n        this.props.update();\n      })\n      .catch(console.error.bind(console));\n  }\n\n  render() {\n    let className = 'themes-list__item';\n    if (!this.state.enabled) {\n      className += ' themes-list__item--deactivated';\n    }\n\n    return (\n      <li className={className}>\n        <input className=\"themes-list__toggle\"\n               type=\"checkbox\"\n               checked={this.state.enabled}\n               onChange={this.handleOnChange}/>\n        <span className=\"themes-list__name\">{this.props.theme.label}</span>\n        <button className=\"themes-list__remove\"\n                onClick={this.handleOnDelete}></button>\n      </li>\n    );\n  }\n}\n\nThemesListItem.propTypes = {\n  theme: React.PropTypes.object.isRequired,\n  update: React.PropTypes.func.isRequired,\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport ThemesListItemView from './themes-list-item';\n\n// @todo Allow editing existing recipes when clicking on the label.\n\nexport default class Themes extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      themes: [],\n    };\n\n    this.foxbox = props.foxbox;\n    this.update = this.update.bind(this);\n  }\n\n  componentDidMount() {\n    this.update();\n  }\n\n  update() {\n    this.foxbox.recipes.getAll()\n      .then((themes) => {\n        this.setState({ themes });\n      })\n      .catch(console.error.bind(console));\n  }\n\n  renderHeader() {\n    return (\n      <header className=\"app-view__header\">\n        <h1>Recipes</h1>\n        <a href=\"#themes/new\" className=\"themes__new-link\">\n          <img className=\"app-view__action-icon\"\n               src=\"css/icons/plus.svg\"\n               alt=\"Add a recipe\"/>\n        </a>\n      </header>\n    );\n  }\n\n  renderBody() {\n    const themeItems = this.state.themes.map((theme) => (\n      <ThemesListItemView key={theme.id}\n                          theme={theme}\n                          update={this.update}\n                          foxbox={this.foxbox} />\n    ));\n\n    return (\n      <div className=\"app-view__fill-body themes\">\n        <ul className=\"themes-list\">{themeItems}</ul>\n      </div>\n    );\n  }\n}\n","import React from 'components/react';\n\nimport BaseView from './base-view';\n\n// @todo Validate input on select onChange:\n//    * Check if integer\n//    * Check if value is within boundaries\n//    * Check if properties belong to selected service\n\nexport default class ThemesNew extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      getters: [],\n      setters: [],\n\n      selectedGetterIndex: -1,\n      selectedGetterValueIndex: -1,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.updateServices = this.updateServices.bind(this);\n    this.onGetterSelected = this.onGetterSelected.bind(this);\n    this.onGetterValueSelected = this.onGetterValueSelected.bind(this);\n    this.onSetterSelected = this.onSetterSelected.bind(this);\n    this.onSetterValueSelected = this.onSetterValueSelected.bind(this);\n    this.onSaveRecipe = this.onSaveRecipe.bind(this);\n  }\n\n  componentDidMount() {\n    Promise.all([\n      this.foxbox.recipes.getGetters(),\n      this.foxbox.recipes.getSetters(),\n    ])\n    .then((services) => this.updateServices(services))\n    .catch(console.error.bind(console));\n  }\n\n  updateServices([getters, setters] = [[], []]) {\n    this.setState({ getters, setters });\n  }\n\n  onGetterSelected(evt) {\n    let selectedGetterIndex = -1;\n\n    if (evt.target.value) {\n      selectedGetterIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedGetterIndex,\n      selectedGetterValueIndex: -1,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onGetterValueSelected(evt) {\n    let selectedGetterValueIndex = -1;\n\n    if (evt.target.value) {\n      selectedGetterValueIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedGetterValueIndex,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onSetterSelected(evt) {\n    let selectedSetterIndex = -1;\n\n    if (evt.target.value) {\n      selectedSetterIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedSetterIndex,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onSetterValueSelected(evt) {\n    let selectedSetterValueIndex = -1;\n\n    if (evt.target.value) {\n      selectedSetterValueIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedSetterValueIndex,\n    });\n  }\n\n  onSaveRecipe() {\n    if (this.state.selectedSetterValueIndex < 0) {\n      return;\n    }\n\n    const getter = this.state.getters[this.state.selectedGetterIndex];\n    const getterValue = getter.options[this.state.selectedGetterValueIndex];\n\n    const setter = this.state.setters[this.state.selectedSetterIndex];\n    const setterValue = setter.options[this.state.selectedSetterValueIndex];\n\n    const name = `${getter.name} ${getterValue.label}, ` +\n      `${setter.name} ${setterValue.label}.`;\n\n    this.foxbox.recipes.add({\n      name,\n      getter,\n      getterValue,\n      setter,\n      setterValue,\n    })\n    .then(() => {\n      location.hash = '#themes';\n    })\n    .catch((error) => {\n      console.log('Error occurred while saving recipe: ', error);\n    });\n  }\n\n  renderHeader() {\n    let actionButtonClassName = 'app-view__action';\n    if (this.state.setter === null) {\n      actionButtonClassName += ' app-view__action--disabled';\n    }\n\n    return (\n      <header className=\"app-view__header\">\n        <a href=\"#themes\" className=\"app-view__action\">Cancel</a>\n        <h1>New Recipe</h1>\n        <button className={actionButtonClassName}\n                onClick={this.onSaveRecipe}>Done\n        </button>\n      </header>\n    );\n  }\n\n  renderBody() {\n    let headerClassName = 'new-theme__header';\n    if (this.state.selectedGetterValueIndex < 0) {\n      headerClassName += ' new-theme__header--hidden';\n    }\n\n    return (\n      <div className=\"app-view__fill-body new-theme\">\n        <h2 className=\"new-theme__header\">If</h2>\n        {this.renderGetterSelector()}\n        {this.renderGetterValueSelector()}\n\n        <h2 className={headerClassName}>Do</h2>\n        {this.renderSetterSelector()}\n        {this.renderSetterValueSelector()}\n      </div>\n    );\n  }\n\n  renderGetterSelector() {\n    let className = 'new-theme__select';\n    if (this.state.selectedGetterIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const optionNodes = this.state.getters.map((getter, index) => (\n      <option key={index} value={index}>{this.getChannelName(getter)}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedGetterIndex}\n              onChange={this.onGetterSelected}\n              className={className}>\n        <option value=\"\">Select a device</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderGetterValueSelector() {\n    if (this.state.selectedGetterIndex < 0) {\n      // @todo Rethink styling to avoid redundant element.\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.selectedGetterValueIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const options = this.state.getters[this.state.selectedGetterIndex].options;\n    const optionNodes = options.map((option, index) => (\n      <option key={index} value={index}>{option.label}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedGetterValueIndex}\n              onChange={this.onGetterValueSelected}\n              className={className}>\n        <option value=\"\">Select a property</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderSetterSelector() {\n    if (this.state.selectedGetterValueIndex < 0) {\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.selectedSetterIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const optionNodes = this.state.setters.map((setter, index) => (\n      <option key={index} value={index}>{this.getChannelName(setter)}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedSetterIndex}\n              onChange={this.onSetterSelected}\n              className={className}>\n        <option value=\"\">Select a device</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderSetterValueSelector() {\n    if (this.state.selectedSetterIndex < 0) {\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.setter !== null) {\n      className += ' new-theme__select--selected';\n    }\n\n    const options = this.state.setters[this.state.selectedSetterIndex].options;\n    const optionNodes = options.map((option, index) => (\n      <option key={index} value={index}>{option.label}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedSetterValueIndex}\n              onChange={this.onSetterValueSelected}\n              className={className}>\n        <option value=\"\">Select a property</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  getChannelName(channel) {\n    // If channel has tags, let's use them as channel identifier.\n    const tags = channel.tags.join(', ');\n    return tags ? `${channel.name} (${tags})` : channel.name;\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport Themes from '../views/themes';\nimport ThemesNew from '../views/themes-new';\n\nexport default class ThemesController extends BaseController {\n  main(action = 'list') {\n    const props = {\n      foxbox: this.foxbox,\n    };\n\n    switch (action) {\n      case 'list':\n        ReactDOM.render(React.createElement(Themes, props), this.mountNode);\n        break;\n\n      case 'new':\n        ReactDOM.render(React.createElement(ThemesNew, props), this.mountNode);\n        break;\n\n      default:\n        //ReactDOM.render(React.createElement(Theme, props), this.mountNode);\n        break;\n    }\n\n  }\n}\n","import React from 'components/react';\n\nimport BaseView from '../base-view';\n\nexport default class CameraLatestImage extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      service: null,\n      hasPreview: false,\n    };\n\n    this.foxbox = props.foxbox;\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service });\n\n        return service.getLatestImage();\n      })\n      .then((image) => {\n        this.refs.snapshotPreview.src = URL.createObjectURL(image);\n        this.setState({ hasPreview: true });\n      })\n      .catch((error) => {\n        console.error(\n          'Error occurred while retrieving latest image for camera (id=%s): ',\n          this.props.id,\n          error\n        );\n      });\n  }\n\n  renderHeader() {\n    return super.renderHeader(\n      this.state.service && this.state.service.name ?\n        this.state.service.name :\n        'Unknown Service'\n    );\n  }\n\n  renderBody() {\n    let cameraControlsClass = 'app-view__fill-body camera-controls';\n    if (this.state.hasPreview) {\n      cameraControlsClass += ' camera-controls--has-preview';\n    }\n\n    return (\n      <div className={cameraControlsClass}>\n        <img ref=\"snapshotPreview\"\n             style={{ flexGrow: 0 }}\n             alt={'Snapshot preview'} className=\"camera-controls__preview\" />\n        <div className=\"camera-controls__empty-preview\">\n          <p>Preview is being loaded.</p>\n          <p>Wait a moment please!</p>\n        </div>\n      </div>\n    );\n  }\n}\n\nCameraLatestImage.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\n\nimport BaseController from './base';\nimport CameraLatestImageView from '../views/dev/camera-latest-image';\n\nexport default class DevController extends BaseController {\n  main(path, args) {\n    switch (path) {\n      case 'camera-latest-image':\n        ReactDOM.render(React.createElement(CameraLatestImageView, {\n          id: args,\n          foxbox: this.foxbox,\n        }), this.mountNode);\n        break;\n      default:\n        console.error('Unknown development view path \"%s\"', path);\n        break;\n    }\n  }\n}\n","'use strict';\n\n/*\n * This file provides an helper to add custom events to any object.\n *\n * In order to use this functionality with any object consumer should extend\n * target object class with EventDispatcher:\n *\n * class Obj extends EventDispatcher {}\n * const obj = new Obj();\n *\n * A list of events can be optionally provided and it is recommended to do so.\n * If a list is provided then only the events present in the list will be\n * allowed. Using events not present in the list will cause other functions to\n * throw an error:\n *\n * class Obj extends EventDispatcher {\n *   constructor() {\n *     super(['somethinghappened', 'somethingelsehappened']);\n *   }\n * }\n * const obj = new Obj();\n *\n * The object will have five new methods: 'on', 'once', 'off', 'offAll' and\n * 'emit'. Use 'on' to register a new event-handler:\n *\n * obj.on(\"somethinghappened\", function onSomethingHappened() { ... });\n *\n * If the same event-handler is added multiple times then only one will be\n * registered, e.g.:\n *\n * function onSomethingHappened() { ... }\n * obj.on(\"somethinghappened\", onSomethingHappened);\n * obj.on(\"somethinghappened\", onSomethingHappened); // Does nothing\n *\n * Use 'off' to remove a registered listener:\n *\n * obj.off(\"somethinghappened\", onSomethingHappened);\n *\n * Use 'once' to register a one-time event-handler: it will be automatically\n * unregistered after being called.\n *\n * obj.once(\"somethinghappened\", function onSomethingHappened() { ... });\n *\n * And use 'offAll' to remove all registered event listeners for the specified\n * event:\n *\n * obj.offAll(\"somethinghappened\");\n *\n * When used without parameters 'offAll' removes all registered event handlers,\n * this can be useful when writing unit-tests.\n *\n * Finally use 'emit' to send an event to the registered handlers:\n *\n * obj.emit(\"somethinghappened\");\n *\n * An optional parameter can be passed to 'emit' to be passed to the registered\n * handlers:\n *\n * obj.emit(\"somethinghappened\", 123);\n */\n\nconst assertValidEventName = function(eventName) {\n  if (!eventName || typeof eventName !== 'string') {\n    throw new Error('Event name should be a valid non-empty string!');\n  }\n};\n\nconst assertValidHandler = function(handler) {\n  if (typeof handler !== 'function') {\n    throw new Error('Handler should be a function!');\n  }\n};\n\nconst assertAllowedEventName = function(allowedEvents, eventName) {\n  if (allowedEvents && allowedEvents.indexOf(eventName) < 0) {\n    throw new Error(`Event \"${eventName}\" is not allowed!`);\n  }\n};\n\nconst p = Object.freeze({\n  allowedEvents: Symbol('allowedEvents'),\n  listeners: Symbol('listeners'),\n});\n\nexport default class EventDispatcher {\n  constructor(allowedEvents) {\n    if (typeof allowedEvents !== 'undefined' && !Array.isArray(allowedEvents)) {\n      throw new Error('Allowed events should be a valid array of strings!');\n    }\n\n    this[p.listeners] = new Map();\n    this[p.allowedEvents] = allowedEvents;\n  }\n\n  /**\n   * Registers listener function to be executed once event occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  on(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    let handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      handlers = new Set();\n      this[p.listeners].set(eventName, handlers);\n    }\n\n    // Set.add ignores handler if it has been already registered.\n    handlers.add(handler);\n  }\n\n  /**\n   * Registers listener function to be executed only first time when event\n   * occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  once(eventName, handler) {\n    assertValidHandler(handler);\n\n    const once = (parameters) => {\n      this.off(eventName, once);\n\n      handler.call(this, parameters);\n    };\n\n    this.on(eventName, once);\n  }\n\n  /**\n   * Removes registered listener for the specified event.\n   *\n   * @param {string} eventName Name of the event to remove listener for.\n   * @param {function} handler Handler to remove, so it won't be executed\n   * next time event occurs.\n   */\n  off(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.delete(handler);\n\n    if (!handlers.size) {\n      this[p.listeners].delete(eventName);\n    }\n  }\n\n  /**\n   * Removes all registered listeners for the specified event.\n   *\n   * @param {string=} eventName Name of the event to remove all listeners for.\n   */\n  offAll(eventName) {\n    if (typeof eventName === 'undefined') {\n      this[p.listeners].clear();\n      return;\n    }\n\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.clear();\n\n    this[p.listeners].delete(eventName);\n  }\n\n  /**\n   * Emits specified event so that all registered handlers will be called\n   * with the specified parameters.\n   *\n   * @param {string} eventName Name of the event to call handlers for.\n   * @param {Object=} parameters Optional parameters that will be passed to\n   * every registered handler.\n   */\n  emit(eventName, parameters) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.forEach((handler) => {\n      try {\n        handler.call(this, parameters);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  /**\n   * Checks if there are any listeners that listen for the specified event.\n   *\n   * @param {string} eventName Name of the event to check listeners for.\n   * @returns {boolean}\n   */\n  hasListeners(eventName) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    return this[p.listeners].has(eventName);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\n\n// Prefix all entries to avoid collisions.\nconst PREFIX = 'foxbox-';\n\n/**\n * API version to use (currently not configurable).\n * @type {number}\n * @const\n */\nconst API_VERSION = 1;\n\n/**\n * Name of the query string parameter that should be presented in URLs pointing\n * to box endpoints (eg. streams, event sources etc.) if authorisation HTTP\n * header can't be attached.\n * @type {string}\n * @const\n */\nconst QUERY_STRING_AUTH_TOKEN_NAME = 'auth';\n\n/**\n * Regex to match upper case literals.\n * @type {RegExp}\n * @const\n */\nconst UPPER_CASE_REGEX = /([A-Z])/g;\n\nconst p = Object.freeze({\n  values: Symbol('values'),\n  storage: Symbol('storage'),\n\n  // Private methods.\n  updateSetting: Symbol('updateSetting'),\n  stringToSettingTypedValue: Symbol('stringToSettingTypedValue'),\n  getDefaultSettingValue: Symbol('getDefaultSettingValue'),\n  onStorage: Symbol('onStorage'),\n});\n\n// Definition of all available settings and their default values (if needed).\nconst settings = Object.freeze({\n  // Boolean settings.\n  CONFIGURED: Object.freeze({ key: 'configured', type: 'boolean' }),\n  SKIP_DISCOVERY: Object.freeze({ key: 'skipDiscovery', type: 'boolean' }),\n  SERVICE_POLLING_ENABLED: Object.freeze({\n    key: 'servicePollingEnabled',\n    type: 'boolean',\n    defaultValue: true,\n  }),\n\n  // Number settings.\n  SERVICE_POLLING_INTERVAL: Object.freeze({\n    key: 'servicePollingInterval',\n    type: 'number',\n    defaultValue: 2000,\n  }),\n  WATCH_INTERVAL: Object.freeze({\n    key: 'watchInterval',\n    type: 'number',\n    defaultValue: 3000,\n  }),\n  ONLINE_CHECKING_INTERVAL: Object.freeze({\n    key: 'onlineCheckingInterval',\n    type: 'number',\n    defaultValue: 5000,\n  }),\n  ONLINE_CHECKING_LONG_INTERVAL: Object.freeze({\n    key: 'onlineCheckingLongInterval',\n    type: 'number',\n    defaultValue: 1000 * 60 * 5,\n  }),\n\n  // String settings.\n  LOCAL_ORIGIN: Object.freeze({ key: 'localOrigin' }),\n  TUNNEL_ORIGIN: Object.freeze({ key: 'tunnelOrigin' }),\n  CLIENT: Object.freeze({ key: 'client' }),\n  SESSION: Object.freeze({ key: 'session' }),\n  PUSH_ENDPOINT: Object.freeze({ key: 'pushEndpoint' }),\n  PUSH_PUB_KEY: Object.freeze({ key: 'pushPubKey' }),\n  PUSH_AUTH: Object.freeze({ key: 'pushAuth' }),\n  REGISTRATION_SERVICE: Object.freeze({\n    key: 'registrationService',\n    defaultValue: 'https://knilxof.org:4443/ping',\n  }),\n});\n\nexport default class Settings extends EventDispatcher {\n  constructor(storage = localStorage) {\n    super();\n\n    // Not all browsers have localStorage supported or activated.\n    this[p.storage] = storage || {\n      getItem: () => null,\n      setItem: () => {},\n      removeItem: () => {},\n      clear: () => {},\n    };\n\n    this[p.values] = new Map();\n\n    Object.keys(settings).forEach((settingName) => {\n      const setting = settings[settingName];\n      const settingStringValue = this[p.storage].getItem(\n        `${PREFIX}${setting.key}`\n      );\n\n      // Setting values directly to avoid firing events on startup.\n      this[p.values].set(\n        setting,\n        this[p.stringToSettingTypedValue](setting, settingStringValue)\n      );\n    });\n\n    window.addEventListener('storage', this[p.onStorage].bind(this));\n\n    Object.seal(this);\n  }\n\n  get configured() {\n    return this[p.values].get(settings.CONFIGURED);\n  }\n\n  set configured(value) {\n    this[p.updateSetting](settings.CONFIGURED, value);\n  }\n\n  get localOrigin() {\n    return this[p.values].get(settings.LOCAL_ORIGIN);\n  }\n\n  set localOrigin(value) {\n    this[p.updateSetting](\n      settings.LOCAL_ORIGIN,\n      value ? (new URL(value)).origin : null\n    );\n  }\n\n  get tunnelOrigin() {\n    return this[p.values].get(settings.TUNNEL_ORIGIN);\n  }\n\n  set tunnelOrigin(value) {\n    this[p.updateSetting](\n      settings.TUNNEL_ORIGIN,\n      value ? (new URL(value)).origin : null\n    );\n  }\n\n  get client() {\n    return this[p.values].get(settings.CLIENT);\n  }\n\n  set client(value) {\n    this[p.updateSetting](settings.CLIENT, value ? String(value) : null);\n  }\n\n  get session() {\n    return this[p.values].get(settings.SESSION);\n  }\n\n  set session(value) {\n    this[p.updateSetting](settings.SESSION, value);\n  }\n\n  get skipDiscovery() {\n    return this[p.values].get(settings.SKIP_DISCOVERY);\n  }\n\n  set skipDiscovery(value) {\n    this[p.updateSetting](settings.SKIP_DISCOVERY, value);\n  }\n\n  get servicePollingEnabled() {\n    return this[p.values].get(settings.SERVICE_POLLING_ENABLED);\n  }\n\n  set servicePollingEnabled(value) {\n    this[p.updateSetting](settings.SERVICE_POLLING_ENABLED, value);\n  }\n\n  get pushEndpoint() {\n    return this[p.values].get(settings.PUSH_ENDPOINT);\n  }\n\n  set pushEndpoint(value) {\n    this[p.updateSetting](settings.PUSH_ENDPOINT, value);\n  }\n\n  get pushPubKey() {\n    return this[p.values].get(settings.PUSH_PUB_KEY);\n  }\n\n  set pushPubKey(value) {\n    this[p.updateSetting](settings.PUSH_PUB_KEY, value);\n  }\n\n  get pushAuth() {\n    return this[p.values].get(settings.PUSH_AUTH);\n  }\n\n  set pushAuth(value) {\n    this[p.updateSetting](settings.PUSH_AUTH, value);\n  }\n\n  // Getters only.\n  get registrationService() {\n    return this[p.values].get(settings.REGISTRATION_SERVICE);\n  }\n\n  get servicePollingInterval() {\n    return this[p.values].get(settings.SERVICE_POLLING_INTERVAL);\n  }\n\n  get onlineCheckingInterval() {\n    return this[p.values].get(settings.ONLINE_CHECKING_INTERVAL);\n  }\n\n  get onlineCheckingLongInterval() {\n    return this[p.values].get(settings.ONLINE_CHECKING_LONG_INTERVAL);\n  }\n\n  /**\n   * Minimal interval between consequent value watcher requests.\n   * @return {number}\n   */\n  get watchInterval() {\n    return this[p.values].get(settings.WATCH_INTERVAL);\n  }\n\n  get queryStringAuthTokenName() {\n    return QUERY_STRING_AUTH_TOKEN_NAME;\n  }\n\n  get apiVersion() {\n    return API_VERSION;\n  }\n\n  /**\n   * Iterates through all known settings and sets default value for all of them.\n   *\n   * @return {Promise}\n   */\n  clear() {\n    return new Promise((resolve) => {\n      Object.keys(settings).forEach((settingName) => {\n        const setting = settings[settingName];\n        this[p.updateSetting](setting, this[p.getDefaultSettingValue](setting));\n      });\n      resolve();\n    });\n  }\n\n  /**\n   * Tries to update setting with new value. If value has changed corresponding\n   * event will be emitted. New value is also persisted to the local storage.\n   *\n   * @param {Object} setting Setting description object.\n   * @param {number|boolean|string?} newValue New value for specified setting.\n   * @private\n   */\n  [p.updateSetting](setting, newValue) {\n    const currentValue = this[p.values].get(setting);\n    if (currentValue === newValue) {\n      return;\n    }\n\n    this[p.values].set(setting, newValue);\n\n    if (newValue !== this[p.getDefaultSettingValue](setting)) {\n      this[p.storage].setItem(`${PREFIX}${setting.key}`, newValue);\n    } else {\n      this[p.storage].removeItem(`${PREFIX}${setting.key}`);\n    }\n\n    this.emit(\n      setting.key.replace(UPPER_CASE_REGEX, (part) => `-${part.toLowerCase()}`),\n      newValue\n    );\n  }\n\n  /**\n   * Converts setting raw string value to the typed one depending on the setting\n   * type.\n   *\n   * @param {Object} setting Setting description object.\n   * @param {string?} stringValue Raw string setting value or null.\n   * @return {number|boolean|string|null}\n   * @private\n   */\n  [p.stringToSettingTypedValue](setting, stringValue) {\n    // If string is null, we should return default value for this setting or\n    // default value for setting type.\n    if (stringValue === null) {\n      return this[p.getDefaultSettingValue](setting);\n    } else if (setting.type === 'boolean') {\n      return stringValue === 'true';\n    } else if (setting.type === 'number') {\n      return Number(stringValue);\n    }\n\n    return stringValue;\n  }\n\n  /**\n   * Gets default typed value for the specified setting.\n   *\n   * @param {Object} setting Setting description object.\n   * @return {number|boolean|string|null}\n   * @private\n   */\n  [p.getDefaultSettingValue](setting) {\n    if (setting.defaultValue !== undefined) {\n      return setting.defaultValue;\n    }\n\n    // Default value for this setting is not specified, let's return default\n    // value for setting type (boolean, number or string).\n    if (setting.type === 'boolean') {\n      return false;\n    } else if (setting.type === 'number') {\n      return 0;\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles localStorage \"storage\" event.\n   *\n   * @param {StorageEvent} evt StorageEvent instance.\n   * @private\n   */\n  [p.onStorage](evt) {\n    if (!evt.key.startsWith(PREFIX)) {\n      return;\n    }\n\n    const key = evt.key.substring(PREFIX.length);\n    const settingName = Object.keys(settings).find((settingName) => {\n      return settings[settingName].key === key;\n    });\n\n    if (!settingName) {\n      console.warn(\n        `Changed unknown storage entry with app specific prefix: ${evt.key}`\n      );\n      return;\n    }\n\n    const setting = settings[settingName];\n\n    this[p.updateSetting](\n      setting,\n      this[p.stringToSettingTypedValue](setting, evt.newValue)\n    );\n  }\n}\n","'use strict';\n\nconst p = Object.freeze({\n  promise: Symbol('promise'),\n  resolve: Symbol('resolve'),\n  reject: Symbol('reject'),\n});\n\n/**\n * Instance of the Defer class is just a handy wrapper around native Promise\n * object intended to provide dedicated 'resolve' and 'reject' methods.\n */\nexport default class Defer {\n  constructor() {\n    this[p.promise] = new Promise((resolve, reject) => {\n      this[p.resolve] = resolve;\n      this[p.reject] = reject;\n    });\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Actual promise instance.\n   *\n   * @return {Promise}\n   */\n  get promise() {\n    return this[p.promise];\n  }\n\n  /**\n   * Resolves promise with the specified value.\n   *\n   * @param {*=} value Optional value to resolve promise with.\n   */\n  resolve(value) {\n    this[p.resolve](value);\n  }\n\n  /**\n   * Rejects promise with the specified error.\n   *\n   * @param {*=} error Error to reject promise with.\n   */\n  reject(error) {\n    this[p.reject](error);\n  }\n}\n","'use strict';\n\nimport Defer from './common/defer';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  db: Symbol('db'),\n  initializationStarted: Symbol('initializationStarted'),\n\n  // Private methods.\n  upgradeSchema: Symbol('upgradeSchema'),\n  getAll: Symbol('getAll'),\n  getById: Symbol('getById'),\n  set: Symbol('set'),\n  remove: Symbol('remove'),\n  clearDb: Symbol('clearDb'),\n});\n\n// The name of the db.\nconst DB_NAME = 'foxbox-db';\n\n// The version of the indexed database.\nconst DB_VERSION = 1;\n\nconst DB_SERVICE_STORE = 'services';\n\nexport default class Db {\n  constructor() {\n    this[p.db] = new Defer();\n    this[p.initializationStarted] = false;\n\n    Object.seal(this);\n  }\n\n  init() {\n    // We don't to expose internal DB object outside of DB class.\n    const initializationPromise = this[p.db].promise.then(() => {});\n\n    if (this[p.initializationStarted]) {\n      return initializationPromise;\n    }\n\n    try {\n      const req = indexedDB.open(DB_NAME, DB_VERSION);\n\n      req.onupgradeneeded = this[p.upgradeSchema];\n      req.onsuccess = (evt) => this[p.db].resolve(evt.target.result);\n      req.onerror = (error) => this[p.db].reject(error);\n    } catch(error) {\n      this[p.db].reject(error);\n    }\n\n    return initializationPromise\n      .catch((error) => {\n        console.error('Error opening database: %o', error);\n        throw error;\n      });\n  }\n\n  clear() {\n    return this[p.db].promise\n      .then((db) => {\n        db.close();\n\n        return new Promise((resolve, reject) => {\n          const req = indexedDB.deleteDatabase(DB_NAME);\n          req.onsuccess = resolve;\n          req.onerror = reject;\n          req.onblocked = reject;\n        });\n      })\n      .then(() => {\n        this[p.db] = new Defer();\n        this[p.initializationStarted] = false;\n      });\n  }\n\n  getServices() {\n    return this[p.getAll](DB_SERVICE_STORE);\n  }\n\n  getService(id) {\n    return this[p.getById](DB_SERVICE_STORE, id);\n  }\n\n  setService(data) {\n    return this[p.set](DB_SERVICE_STORE, data);\n  }\n\n  deleteService(data) {\n    return this[p.remove](DB_SERVICE_STORE, data.id);\n  }\n\n  clearServices() {\n    return this[p.clearDb](DB_SERVICE_STORE);\n  }\n\n  [p.upgradeSchema](evt) {\n    const db = evt.target.result;\n    const fromVersion = evt.oldVersion;\n    if (fromVersion < 1) {\n      const store = db.createObjectStore(DB_SERVICE_STORE, { keyPath: 'id' });\n      store.createIndex('id', 'id', { unique: true });\n    }\n  }\n\n  [p.getAll](store) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readonly');\n          const results = [];\n          txn.onerror = reject;\n          txn.oncomplete = () => resolve(results);\n          txn.objectStore(store).openCursor().onsuccess = (evt) => {\n            const cursor = evt.target.result;\n            if (cursor) {\n              results.push(cursor.value);\n              cursor.continue();\n            }\n          };\n        });\n      });\n  }\n\n  [p.getById](store, id) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readonly');\n          txn.onerror = reject;\n          txn.objectStore(store).get(id).onsuccess = (evt) => {\n            resolve(evt.target.result);\n          };\n        });\n      });\n  }\n\n  [p.set](store, data) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          try {\n            txn.objectStore(store).put(data);\n          } catch (error) {\n            console.error(`Error putting data in ${DB_NAME}:`, error);\n            resolve();\n          }\n        });\n      });\n  }\n\n  [p.remove](store, id) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          try {\n            txn.objectStore(store).delete(id);\n          } catch (error) {\n            console.error(`Error deleting data from ${DB_NAME}:`, error);\n            resolve();\n          }\n        });\n      });\n  }\n\n  [p.clearDb](store) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          txn.objectStore(store).clear();\n        });\n      });\n  }\n}\n","'use strict';\n\nconst p = Object.freeze({\n  started: Symbol('started'),\n  nextTickHandle: Symbol('nextTickHandle'),\n\n  // Private methods.\n  scheduleTick: Symbol('scheduleTick'),\n  onTick: Symbol('onTick'),\n});\n\nexport default class SequentialTimer {\n  /**\n   * Creates new SequentialTimer instance.\n   * @param {number} interval Minimum interval between two consequent ticks.\n   */\n  constructor(interval) {\n    this.interval = interval;\n\n    this[p.started] = false;\n    this[p.nextTickHandle] = null;\n    this[p.onTick] = null;\n\n    Object.seal(this);\n  }\n\n  /**\n   * Indicates whether timer started or not.\n   *\n   * @return {boolean}\n   */\n  get started() {\n    return this[p.started];\n  }\n\n  /**\n   * Starts timer. If timer has already been started nothing happens.\n   * @param {function} onTick Function that will be called on every tick.\n   */\n  start(onTick) {\n    if (this[p.started]) {\n      console.warn('Timer has been already started.');\n      return;\n    }\n\n    if (typeof onTick !== 'function') {\n      throw new Error('onTick handler should be a valid function.');\n    }\n\n    this[p.started] = true;\n    this[p.onTick] = onTick;\n\n    this[p.scheduleTick]();\n  }\n\n  /**\n   * Stops timer. If timer has not been started yet nothing happens.\n   */\n  stop() {\n    if (!this[p.started]) {\n      console.warn('Timer has not been started yet.');\n      return;\n    }\n\n    this[p.started] = false;\n\n    clearTimeout(this[p.nextTickHandle]);\n    this[p.nextTickHandle] = null;\n    this[p.onTick] = null;\n  }\n\n  /**\n   * Schedules next tick.\n   *\n   * @private\n   */\n  [p.scheduleTick]() {\n    if (!this[p.started] || this[p.nextTickHandle]) {\n      return;\n    }\n\n    this[p.nextTickHandle] = setTimeout(() => {\n      // Use Promise constructor to handle all possible results e.g. promises,\n      // unexpected exceptions and any other non-promise values.\n      (new Promise((resolve) => resolve(this[p.onTick]())))\n        .catch((error) => {\n          console.error(\n            'onTick handler failed, scheduling next tick anyway: %o',\n            error\n          );\n        })\n        .then(() => {\n          this[p.nextTickHandle] = null;\n          this[p.scheduleTick]();\n        });\n    }, this.interval);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  origin: Symbol('origin'),\n  online: Symbol('online'),\n  lastSeenOnline: Symbol('lastSeenOnline'),\n\n  pingTimer: Symbol('pingTimer'),\n\n  // Private methods.\n  ping: Symbol('ping'),\n});\n\nexport default class BoxLink extends EventDispatcher {\n  constructor(origin) {\n    super(['online']);\n\n    if (!origin) {\n      throw new Error('Origin should be valid non-empty string.');\n    }\n\n    this[p.ping] = this[p.ping].bind(this);\n\n    this[p.origin] = origin;\n    this[p.online] = false;\n    this[p.lastSeenOnline] = 0;\n    this[p.pingTimer] = new SequentialTimer(Number.POSITIVE_INFINITY);\n\n    Object.seal(this);\n  }\n\n  get origin() {\n    return this[p.origin];\n  }\n\n  get online() {\n    return this[p.online];\n  }\n\n  /**\n   * Marks current box link as online. Method is called by the consumer to\n   * indicate that box has been seen online by other means than ping itself.\n   */\n  seenOnline() {\n    this[p.online] = true;\n    this[p.lastSeenOnline] = Date.now();\n  }\n\n  /**\n   * Enables automatic box link ping using specified interval.\n   *\n   * @param {number} interval Minimum interval that should be kept between two\n   * consequent ping requests.\n   */\n  enableAutoPing(interval) {\n    if (typeof interval !== 'number' || interval < 0) {\n      throw new Error('Interval should valid positive number.');\n    }\n\n    this[p.pingTimer].interval = interval;\n    if (!this[p.pingTimer].started) {\n      this[p.pingTimer].start(this[p.ping]);\n    }\n  }\n\n  /**\n   * Disables automatic box link ping.\n   */\n  disableAutoPing() {\n    if (!this[p.pingTimer].started) {\n      return;\n    }\n\n    this[p.pingTimer].stop();\n  }\n\n  /**\n   * Pings box link. Ping will be made immediately. Return promise will be\n   * resolved into boolean that indicates whether box link online or not.\n   *\n   * @return {Promise<boolean>}\n   */\n  ping() {\n    return this[p.ping](true /* force ping */);\n  }\n\n  /**\n   * Performs HTTP 'GET' request link's \"ping\" endpoint. Returns 'true' if\n   * response was successful (any of 200-299 status codes) or 'false'\n   * otherwise.\n   *\n   * @param {boolean} force Indicates that we should perform ping request even\n   * if the box was pinged recently.\n   * @return {Promise<boolean>}\n   * @private\n   */\n  [p.ping](force) {\n    // If ping is not forced and box link was seen online recently, we don't\n    // have to ping it again.\n    const seenOnlineRecently = Date.now() - this[p.lastSeenOnline] <\n      this[p.pingTimer].interval;\n    if (!force && (seenOnlineRecently || document.hidden)) {\n      return Promise.resolve();\n    }\n\n    return fetch(`${this[p.origin]}/ping`, { cache: 'no-store' })\n      .then(\n        (res) => res.ok,\n        (error) => {\n          console.error('Error occurred while pinging box: %o', error);\n          return false;\n        })\n      .then((isOnline) => {\n        if (isOnline) {\n          this[p.lastSeenOnline] = Date.now();\n        }\n\n        if (this[p.online] === isOnline) {\n          return;\n        }\n\n        this[p.online] = isOnline;\n        this.emit('online', isOnline);\n\n        return isOnline;\n      });\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport BoxLink from './box-link';\n\nconst p = Object.freeze({\n  // Private properties.\n  settings: Symbol('settings'),\n\n  localLink: Symbol('localLink'),\n  tunnelLink: Symbol('tunnelLink'),\n  linkPingInterval: Symbol('linkPingInterval'),\n  online: Symbol('online'),\n\n  // Private methods.\n  fetch: Symbol('fetch'),\n  pingLinks: Symbol('pingLinks'),\n  updateLink: Symbol('updateLink'),\n  onLinkOnlineChange: Symbol('onLinkOnlineChange'),\n  onLinkOriginChange: Symbol('onLinkOriginChange'),\n});\n\nexport default class Network extends EventDispatcher {\n  constructor(settings) {\n    super(['online']);\n\n    this[p.settings] = settings;\n    // Local box link that allows to connect to the box via local connection.\n    this[p.localLink] = null;\n    // Tunnel box link that allows to connect to the box via tunnel connection.\n    this[p.tunnelLink] = null;\n    this[p.linkPingInterval] = null;\n    this[p.online] = false;\n\n    this[p.pingLinks] = this[p.pingLinks].bind(this);\n    this[p.onLinkOnlineChange] = this[p.onLinkOnlineChange].bind(this);\n    this[p.onLinkOriginChange] = this[p.onLinkOriginChange].bind(this);\n\n    Object.seal(this);\n  }\n\n  /**\n   * Attach event listeners related to the connection status.\n   *\n   * @return {Promise}\n   */\n  init() {\n    window.addEventListener('online', this[p.pingLinks]);\n    window.addEventListener('offline', this[p.pingLinks]);\n\n    if ('connection' in navigator && 'onchange' in navigator.connection) {\n      navigator.connection.addEventListener('change', this[p.pingLinks]);\n\n      // We also ping the box every few minutes to make sure it's still there.\n      this[p.linkPingInterval] = this[p.settings].onlineCheckingLongInterval;\n    } else {\n      // If the Network Information API is not implemented, fallback to polling.\n      this[p.linkPingInterval] = this[p.settings].onlineCheckingInterval;\n    }\n\n    this[p.settings].on('local-origin', this[p.onLinkOriginChange]);\n    this[p.settings].on('tunnel-origin', this[p.onLinkOriginChange]);\n\n    this[p.onLinkOriginChange]();\n\n    return Promise.resolve();\n  }\n\n  get origin() {\n    if (this[p.localLink]) {\n      return this[p.localLink].origin;\n    } else if (this[p.tunnelLink]) {\n      return this[p.tunnelLink].origin;\n    }\n\n    throw new Error('Origin is not accessible');\n  }\n\n  get localOrigin() {\n    return this[p.settings].localOrigin;\n  }\n\n  get tunnelOrigin() {\n    return this[p.settings].tunnelOrigin;\n  }\n\n  get online() {\n    return this[p.online];\n  }\n\n  /**\n   * Request a JSON from a specified URL.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} method The HTTP method (defaults to \"GET\").\n   * @param {Object} body An object of key/value.\n   * @return {Promise}\n   */\n  fetchJSON(url, method = 'GET', body = undefined) {\n    return this[p.fetch](url, 'application/json', method, body)\n      .then((response) => response.json());\n  }\n\n  /**\n   * Request a Blob from a specified URL.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} blobType The Blob mime type (eg. image/jpeg).\n   * @param {string=} method The HTTP method (defaults to \"GET\").\n   * @param {Object=} body An object of key/value.\n   * @return {Promise<Blob>}\n   */\n  fetchBlob(url, blobType, method, body) {\n    return this[p.fetch](url, blobType, method, body)\n      .then((response) => response.blob());\n  }\n\n  /**\n   * Request a content of the specified type from a specified URL.\n   *\n   * @todo Detect if the URL is relative, if so prepend this.origin.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} accept The content mime type (eg. image/jpeg).\n   * @param {string=} method The HTTP method (defaults to \"GET\").\n   * @param {Object=} body An object of key/value.\n   * @return {Promise}\n   * @private\n   */\n  [p.fetch](url, accept, method = 'GET', body = undefined) {\n    method = method.toUpperCase();\n\n    const req = {\n      method,\n      headers: { Accept: accept },\n      cache: 'no-store',\n    };\n\n    if (method === 'POST' || method === 'PUT' || method === 'DELETE') {\n      req.headers['Content-Type'] = 'application/json;charset=UTF-8';\n    }\n\n    if (this[p.settings].session) {\n      // The user is logged in, we authenticate the request.\n      req.headers.Authorization = `Bearer ${this[p.settings].session}`;\n    }\n\n    if (body !== undefined) {\n      req.body = JSON.stringify(body);\n    }\n\n    return fetch(url, req)\n      .then((res) => {\n        if (!res.ok) {\n          throw new TypeError(\n            `The response returned a ${res.status} HTTP status code.`\n          );\n        }\n\n        // Let's check if request has been made to any of existing box links,\n        // in this case we can mark it as online eliminating redundant ping\n        // request.\n        const requestOrigin = (new URL(url)).origin;\n        if (this[p.localLink] && this[p.localLink].origin === requestOrigin) {\n          this[p.localLink].seenOnline();\n        } else if (this[p.tunnelLink] &&\n                   this[p.tunnelLink].origin === requestOrigin) {\n          this[p.tunnelLink].seenOnline();\n        }\n\n        return res;\n      })\n      .catch((error) => {\n        console.error('Error occurred while fetching content: ', error);\n        throw error;\n      });\n  }\n\n  /**\n   * Pings both local and tunnel box links simultaneously (if discovered).\n   *\n   * @private\n   */\n  [p.pingLinks]() {\n    if (this[p.localLink]) {\n      this[p.localLink].ping();\n    }\n\n    if (this[p.tunnelLink]) {\n      this[p.tunnelLink].ping();\n    }\n  }\n\n  /**\n   * Updates specified link. Link is updated if origin has changed, if origin\n   * became \"null\" link will be deleted.\n   *\n   * @param {Symbol} symbol Symbol associated either with local or tunnel link.\n   * @param {string?} origin Origin string, if \"null\" - origin is not available\n   * anymore.\n   * @private\n   */\n  [p.updateLink](symbol, origin) {\n    const link = this[symbol];\n\n    // Update is not required if we have neither origin nor link for it or if\n    // existing link's origin isn't changed.\n    if ((!origin && !link) || (link && link.origin === origin)) {\n      return;\n    }\n\n    // Let's destroy old link if origin is changed or not available anymore.\n    if (link) {\n      link.off('online', this[p.onLinkOnlineChange]);\n      link.disableAutoPing();\n      this[symbol] = null;\n    }\n\n    if (origin) {\n      this[symbol] = new BoxLink(origin);\n      this[symbol].enableAutoPing(this[p.linkPingInterval]);\n      this[symbol].on('online', this[p.onLinkOnlineChange]);\n      // Ping box link immediately once it's created to get \"online\" status as\n      // soon as possible.\n      this[symbol].ping();\n    }\n\n    // It doesn't matter whether link has been added or removed we should try to\n    // update \"online\" status.\n    this[p.onLinkOnlineChange]();\n  }\n\n  /**\n   * Updates box links whenever local or tunnel origin has changed.\n   *\n   * @private\n   */\n  [p.onLinkOriginChange]() {\n    this[p.updateLink](p.localLink, this.localOrigin);\n    this[p.updateLink](p.tunnelLink, this.tunnelOrigin);\n  }\n\n  /**\n   * Updates overall \"online\" status whenever either local or tunnel link\n   * \"online\" status has changed. If overall status has changed \"online\" event\n   * is emitted.\n   *\n   * @private\n   */\n  [p.onLinkOnlineChange]() {\n    const onlineStatus = !!this[p.localLink] && this[p.localLink].online ||\n      !!this[p.tunnelLink] && this[p.tunnelLink].online;\n\n    if (this[p.online] !== onlineStatus) {\n      this[p.online] = onlineStatus;\n      this.emit('online', onlineStatus);\n    }\n  }\n}\n","'use strict';\n\n// @todo Proxy recipes in the db and emit events on change (see services).\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  api: Symbol('api'),\n\n  // Recipe private properties.\n  service: Symbol('service'),\n});\n\nexport class Recipe {\n  constructor(service) {\n    if (!service) {\n      throw new Error('Service is required!');\n    }\n\n    this[p.service] = service;\n  }\n\n  get id() {\n    return this[p.service].id;\n  }\n\n  get label() {\n    return this[p.service].source && this[p.service].source.name;\n  }\n\n  get enabled() {\n    return this[p.service].status;\n  }\n}\n\nexport default class Recipes {\n  constructor(api) {\n    this[p.api] = api;\n\n    Object.seal(this);\n  }\n\n  /**\n   * Returns a promise resolving to a list of recipes.\n   *\n   * @return {Promise}\n   */\n  getAll() {\n    return this[p.api].post(\n      'services',\n      { channels: [{ feature: 'thinkerbell/rule-source' }] }\n    )\n    // Mark channels with more friendly names.\n    .then((services) => {\n      return services.map((service) => {\n        return Object.keys(service.channels).reduce((rule, channelId) => {\n          const channel = service.channels[channelId];\n\n          switch (channel.feature) {\n            case 'thinkerbell/is-rule-enabled':\n              rule.enabled = channelId;\n              break;\n            case 'thinkerbell/rule-source':\n              rule.getSource = channelId;\n              break;\n            case 'thinkerbell/remove-rule-id':\n              rule.remove = channelId;\n              break;\n          }\n\n          return rule;\n        }, {\n          id: service.id,\n          getSource: null,\n          enabled: null,\n          remove: null,\n          status: null,\n          source: null,\n        });\n      });\n    })\n    .then((services) => {\n      // Fetch recipe enabled statuses and sources.\n      const { enabledSelectors, sourceSelectors } = services.reduce(\n        (selectors, service) => {\n          selectors.enabledSelectors.push({ id: service.enabled });\n          selectors.sourceSelectors.push({ id: service.getSource });\n\n          return selectors;\n        },\n        { enabledSelectors: [], sourceSelectors: [] }\n      );\n\n      return Promise.all([\n        this[p.api].put('channels/get', enabledSelectors),\n        this[p.api].put('channels/get', sourceSelectors),\n      ])\n      .then(([statuses, sources]) => {\n        return services.map((service) => {\n          const statusResponse = statuses[service.enabled];\n          const sourceResponse = sources[service.getSource];\n\n          if (statusResponse && statusResponse.OnOff) {\n            service.status = statusResponse.OnOff === 'On';\n          } else {\n            console.error(\n              'Error occurred while retrieving recipe (%s) status: ',\n              service.id,\n              statusResponse && statusResponse.Error\n            );\n            service.status = false;\n          }\n\n          if (sourceResponse && sourceResponse.String) {\n            service.source = JSON.parse(sourceResponse.String);\n          } else {\n            console.error(\n              'Error occurred while retrieving recipe (%s) source: ',\n              service.id,\n              sourceResponse && sourceResponse.Error\n            );\n            service.source = null;\n          }\n\n          return new Recipe(service);\n        });\n      });\n    });\n  }\n\n  getGetters() {\n    // Currently we support only Clock, Motion Sensor and Door Lock as triggers.\n    const supportedFeatures = [\n      'clock/time-of-day-seconds',\n      'door/is-open',\n      'door/is-locked',\n    ];\n\n    return this[p.api].post(\n      'channels',\n      supportedFeatures.map((feature) => ({ feature, supports_fetch: true }))\n    )\n    .then((getters) => {\n      return getters.map((getter) => {\n        let name;\n        const options = [];\n\n        // Assign user friendly name to every getter and it's value options.\n        switch (getter.feature) {\n          case 'clock/time-of-day-seconds':\n            name = 'Everyday';\n            options.push(...[{\n              label: 'in the morning',\n              // 08:00 AM, 8 * 60 * 60 = 28800 seconds from 00:00.\n              value: { Geq: { Duration: 28800 } },\n            }, {\n              label: 'in the afternoon',\n              // 02:00 PM, 14 * 60 * 60 = 50400 seconds from 00:00.\n              value: { Geq: { Duration: 50400 } },\n            }, {\n              label: 'in the evening',\n              // 06:00 PM, 18 * 60 * 60 = 64800 seconds from 00:00.\n              value: { Geq: { Duration: 64800 } },\n            }]);\n            break;\n          case 'door/is-open':\n            name = 'Motion Sensor';\n            options.push({\n              label: 'detects motion',\n              value: { Eq: { OpenClosed: 'Open' } },\n            });\n            break;\n          case 'door/is-locked':\n            name = 'Door';\n            options.push({\n              label: 'is locked',\n              value: { Eq: { DoorLocked: 'Locked' } },\n            }, {\n              label: 'is unlocked',\n              value: { Eq: { DoorLocked: 'Unlocked' } },\n            });\n        }\n\n        return {\n          id: getter.id,\n          feature: getter.feature,\n          name: name || getter.adapter,\n          tags: getter.tags,\n          options,\n        };\n      });\n    });\n  }\n\n  getSetters() {\n    // Currently we support only TTS, camera, connected lights, motion sensor\n    // and door lock as actuators.\n    const supportedFeatures = [\n      'speak/sentence',\n      'camera/store-snapshot',\n      'light/is-on',\n      'door/is-locked',\n    ];\n\n    return this[p.api].post(\n      'channels',\n      supportedFeatures.map((feature) => ({ feature, supports_send: true }))\n    )\n    .then((setters) => {\n      return setters.map((setter) => {\n        const options = [];\n        let name;\n\n        switch (setter.feature) {\n          case 'speak/sentence':\n            name = 'say';\n            options.push(...[\n              {\n                label: '\"Good morning!\"',\n                value: { String: '\"Good morning!\"' },\n              },\n              {\n                label: '\"Good afternoon!\"',\n                value: { String: '\"Good afternoon!\"' },\n              },\n              {\n                label: '\"Good evening!\"',\n                value: { String: '\"Good evening!\"' },\n              },\n            ]);\n            break;\n          case 'camera/store-snapshot':\n            name = 'camera';\n            options.push(...[\n              {\n                label: 'takes a picture',\n                value: { 'Unit': null },\n              },\n              {\n                label: 'sends me a picture',\n                value: [\n                  {\n                    // Take a picture.\n                    destination: [{id: setter.id}],\n                    feature: 'camera/store-snapshot',\n                    value: { Unit: null },\n                  },\n                  {\n                    // Notify the user.\n                    destination: [{ feature: 'webpush/notify-msg' }],\n                    feature: 'webpush/notify-msg',\n                    value: {\n                      WebPushNotify: {\n                        message: JSON.stringify({\n                          message: 'Your bedroom patio door has just been ' +\n                          'opened. Here is a picture of what I see.',\n                          action: `dev/camera-latest-image/${setter.service}`,\n                        }),\n                        resource: 'res1',\n                      },\n                    },\n                  },\n                ],\n              },\n            ]);\n            break;\n          case 'light/is-on':\n            name = 'light';\n            options.push(...[\n              {\n                label: 'gets turned on',\n                value: { OnOff: 'On' },\n              },\n              {\n                label: 'gets turned off',\n                value: { OnOff: 'Off' },\n              },\n            ]);\n            break;\n          case 'door/is-locked':\n            name = 'door lock';\n            options.push(...[\n              {\n                label: 'locks the door',\n                value: { DoorLocked: 'Locked' },\n              },\n              {\n                label: 'unlocks the door',\n                value: { DoorLocked: 'Unlocked' },\n              },\n            ]);\n            break;\n        }\n\n        return {\n          id: setter.id,\n          feature: setter.feature,\n          name: name || setter.adapter,\n          tags: setter.tags,\n          options,\n        };\n      });\n    });\n  }\n\n  /**\n   * Create a new recipe.\n   *\n   * @return {Promise}\n   */\n  add({ name, getter, getterValue, setter, setterValue }) {\n    let execute;\n\n    if (Array.isArray(setterValue.value)) {\n      execute = setterValue.value;\n    } else if (typeof setterValue.value === 'object') {\n      execute = [\n        {\n          destination: [{ id: setter.id }],\n          feature: setter.feature,\n          value: setterValue.value,\n        },\n      ];\n    } else {\n      console.error('Setter doesn\\'t have a supported format:',\n        JSON.stringify(setter));\n    }\n\n    const recipe = {\n      name,\n      rules: [\n        {\n          conditions: [\n            {\n              source: [{ id: getter.id }],\n              feature: getter.feature,\n              range: getterValue.value,\n            },\n          ],\n          execute,\n        },\n      ],\n    };\n\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: {\n          feature: 'thinkerbell/add-rule',\n        },\n        value: {\n          ThinkerbellRule: {\n            name,\n            source: JSON.stringify(recipe),\n          },\n        },\n      }\n    );\n  }\n\n  /**\n   * Remove a recipe with the associated id.\n   *\n   * @param {Recipe} recipe Recipe instance to remove.\n   * @return {Promise}\n   */\n  remove(recipe) {\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: { id: recipe[p.service].remove },\n        value: null,\n      }\n    );\n  }\n\n  /**\n   * Enable or disable the specified recipe.\n   *\n   * @param {Recipe} recipe Recipe to toggle status for.\n   * @param {boolean=} value Whether to enable or disable. Enable by default.\n   * @return {Promise}\n   */\n  toggle(recipe, value = true) {\n    const textValue = value ? 'On' : 'Off';\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: { id: recipe[p.service].enabled },\n        value: { OnOff: textValue },\n      }\n    )\n    .then(() => {\n      recipe[p.service].status = value;\n    });\n  }\n\n  // Hack for the demo.\n  /**\n   * Create the following static recipe:\n   * * When:\n   *    * The first light is on\n   *    * It's 8:00am\n   * * Then:\n   *    * Turn all the lights off\n   *    * Notify the user\n   */\n  createDemoRecipes() {\n    Promise.all([\n        this.getGetters(),\n        this.getSetters(),\n      ])\n      .then(([getters, setters]) => {\n        const clockGetter = getters.find(\n          (getter) => getter.feature === 'clock/time-of-day-seconds'\n        );\n        // Commented until the Philips Hue adapter watcher lands in the box.\n        /*const firstLightGetter = getters.find(\n          (getter) => getter.feature === 'light/is-on'\n        );*/\n        const lightsSetter = setters.filter(\n          (setter) => setter.feature === 'light/is-on'\n        );\n\n        const conditions = [\n          // When it's 8:00am.\n          {\n            source: [{ id: clockGetter.id }],\n            feature: 'clock/time-of-day-seconds',\n            range: { Geq: { Duration: 28800 } },\n          },\n          // When the first light is on.\n          /*{\n            source: [{ id: firstLightGetter.id }],\n            feature: firstLightGetter.feature,\n            range: { Eq: { OnOff: 'On' } },\n          },*/\n        ];\n\n        const execute = [].concat(\n          // Turn off all lights.\n          lightsSetter.map((setter) => ({\n            destination: [{ id: setter.id }],\n            feature: setter.feature,\n            value: { OnOff: 'Off' },\n          })),\n          // Notify the user.\n          [\n            {\n              // Notify the user.\n              destination: [{ feature: 'webpush/notify-msg' }],\n              feature: 'webpush/notify-msg',\n              value: {\n                WebPushNotify: {\n                  message: JSON.stringify({\n                    message: 'Hello Alex, I\\'ve turned your kitchen lights ' +\n                    'off for you. Have a wonderful day!',\n                  }),\n                  resource: 'res1',\n                },\n              },\n            },\n          ]);\n\n        const recipe = {\n          name: 'Turn off the lights when I leave for work.',\n          rules: [\n            {\n              conditions,\n              execute,\n            },\n          ],\n        };\n\n        console.log('Recipe for the demo', recipe);\n\n        return this[p.api].put(\n          'channels/set',\n          {\n            select: {\n              feature: 'thinkerbell/add-rule',\n            },\n            value: {\n              ThinkerbellRule: {\n                name,\n                source: JSON.stringify(recipe),\n              },\n            },\n          }\n        );\n      });\n\n    this.createDoorLockDemoRecipe();\n  }\n\n  /**\n   * Create the following static recipe:\n   * * When:\n   *    * The door is open\n   *    * It's 8:00am\n   * * Then:\n   *    * Close the door\n   *    * Notify the user\n   */\n  createDoorLockDemoRecipe() {\n    Promise.all([\n      this.getGetters(),\n      this.getSetters(),\n    ])\n    .then(([getters, setters]) => {\n      const clockGetter = getters.find(\n        (getter) => getter.feature === 'clock/time-of-day-seconds'\n      );\n\n      const doorLockGetter = getters.find(\n        (getter) => getter.feature === 'door/is-locked'\n      );\n\n      const doorLockSetter = setters.find(\n        (setter) => setter.feature === 'door/is-locked'\n      );\n\n      const conditions = [\n        // When it's 8:00am.\n        {\n          source: [{ id: clockGetter.id }],\n          feature: 'clock/time-of-day-seconds',\n          range: { Geq: { Duration: 28800 } },\n        },\n        {\n          source: [{ id: doorLockGetter.id }],\n          feature: doorLockGetter.feature,\n          range: { Eq: { DoorLocked: 'Unlocked' } },\n        },\n      ];\n\n      const execute = [\n        {\n          destination: [{ id: doorLockSetter.id }],\n          feature: doorLockSetter.feature,\n          value: { DoorLocked: 'Locked' },\n        },\n        {\n          // Notify the user.\n          destination: [{ feature: 'webpush/notify-msg' }],\n          feature: 'webpush/notify-msg',\n          value: {\n            WebPushNotify: {\n              message: JSON.stringify({\n                message: 'Hello Alex, I\\'ve locked the door for you. ' +\n                  'Have a wonderful day!',\n              }),\n              resource: 'res1',\n            },\n          },\n        },\n      ];\n\n      const recipe = {\n        name: 'Lock the door when I leave for work.',\n        rules: [\n          {\n            conditions,\n            execute,\n          },\n        ],\n      };\n\n      return this[p.api].put(\n        'channels/set',\n        {\n          select: {\n            feature: 'thinkerbell/add-rule',\n          },\n          value: {\n            ThinkerbellRule: {\n              name,\n              source: JSON.stringify(recipe),\n            },\n          },\n        }\n      );\n    });\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\n\n// Private members\nconst p = Object.freeze({\n  // Properties,\n  api: Symbol('api'),\n  settings: Symbol('settings'),\n\n  // Methods:\n  listenForMessages: Symbol('listenForMessages'),\n});\n\nexport default class WebPush extends EventDispatcher {\n  constructor(api, settings) {\n    super(['message']);\n\n    this[p.api] = api;\n    this[p.settings] = settings;\n\n    Object.seal(this);\n  }\n\n  subscribeToNotifications(resubscribe = false) {\n    if (!navigator.serviceWorker) {\n      return Promise.reject('No service worker supported');\n    }\n\n    navigator.serviceWorker.addEventListener('message',\n      this[p.listenForMessages].bind(this));\n\n    const settings = this[p.settings];\n    if (settings.pushEndpoint && settings.pushPubKey && settings.pushAuth &&\n        !resubscribe) {\n      return Promise.resolve();\n    }\n\n    return navigator.serviceWorker.ready\n      .then((reg) => reg.pushManager.subscribe({ userVisibleOnly: true }))\n      .then((subscription) => {\n        const endpoint = subscription.endpoint;\n        const key = subscription.getKey ? subscription.getKey('p256dh') : '';\n        const auth = subscription.getKey ? subscription.getKey('auth') : '';\n        settings.pushEndpoint = endpoint;\n        settings.pushPubKey = btoa(String.fromCharCode.apply(null,\n          new Uint8Array(key)));\n        settings.pushAuth = btoa(String.fromCharCode.apply(null,\n          new Uint8Array(auth)));\n\n        // Send push information to the server.\n        // @todo We will need some library to write taxonomy messages.\n        const pushConfigurationMsg = [[\n            [{ id: 'setter:subscribe.webpush@link.mozilla.org' }],\n            {\n              Json: {\n                subscriptions: [{\n                  public_key: settings.pushPubKey,\n                  push_uri: settings.pushEndpoint,\n                  auth: settings.pushAuth,\n                }],\n              },\n            },\n          ]];\n\n        return this[p.api].put('channels/set', pushConfigurationMsg);\n      })\n      .then(() => {\n        // Setup some common push resources.\n        const pushResourcesMsg = [[\n          [{ id: 'setter:resource.webpush@link.mozilla.org' }],\n          { Json: { resources: ['res1'] } },\n        ]];\n\n        return this[p.api].put('channels/set', pushResourcesMsg);\n      })\n      .catch((error) => {\n        if (Notification.permission === 'denied') {\n          throw new Error('Permission request was denied.');\n        }\n\n        console.error('Error while saving subscription ', error);\n        throw new Error(`Subscription error: ${error}`);\n      });\n  }\n\n  [p.listenForMessages](evt) {\n    const msg = evt.data || {};\n\n    if (!msg.action) {\n      return;\n    }\n\n    this.emit('message', msg);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from '../common/event-dispatcher';\n\nconst TYPE = 'unknown';\n\nconst p = Object.freeze({\n  // Private properties.\n  api: Symbol('api'),\n\n  // Public getter only properties.\n  id: Symbol('id'),\n  manufacturer: Symbol('manufacturer'),\n  model: Symbol('model'),\n  name: Symbol('name'),\n  watchers: Symbol('watchers'),\n  tags: Symbol('tags'),\n  channels: Symbol('channels'),\n\n  // Private methods.\n  getChannels: Symbol('getChannel'),\n  getFetchChannel: Symbol('getFetchChannel'),\n  getSendChannel: Symbol('getSendChannel'),\n});\n\nexport default class BaseService extends EventDispatcher {\n  constructor(props, api, allowedEvents, watchers) {\n    super(allowedEvents);\n\n    // Private properties.\n    this[p.api] = api;\n\n    // Public getter only properties.\n    this[p.id] = props.id;\n    this[p.manufacturer] = props.properties && props.properties.manufacturer ||\n      '';\n    this[p.model] = props.properties && props.properties.model || '';\n    // Some service don't have name, but can have product_name instead.\n    this[p.name] = props.properties && props.properties.name ||\n      props.properties.product_name || '';\n    this[p.tags] = new Set(props.tags);\n    this[p.channels] = props.channels;\n    this[p.watchers] = watchers || new Map();\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  get id() {\n    return this[p.id];\n  }\n\n  get manufacturer() {\n    return this[p.manufacturer];\n  }\n\n  get model() {\n    return this[p.model];\n  }\n\n  get name() {\n    return this[p.name];\n  }\n\n  /**\n   * Sets a value via sending it to a service channel.\n   *\n   * @param {Object|string} selector Selector for the channel to use.\n   * @param {*} value Value to set.\n   * @return {Promise}\n   */\n  set(selector, value = null) {\n    const channel = this[p.getSendChannel](selector);\n    const accepts = channel.supports_send.accepts;\n\n    // If channel declares input value type, then we should use it, otherwise\n    // we send a \"null\" value.\n    const payload = [\n      { id: channel.id },\n      accepts ? { [accepts.requires || accepts.optional]: value } : null,\n    ];\n\n    return this[p.api].put('channels/set', [payload]);\n  }\n\n  /**\n   * Gets a value from a service channel.\n   *\n   * @param {Object} selector Selector for the channel to use.\n   * @return {Promise}\n   */\n  get(selector) {\n    const channel = this[p.getFetchChannel](selector);\n    const returns = channel.supports_fetch.returns;\n    const payload = { id: channel.id };\n\n    // If we expect binary data let's request it properly.\n    if (returns && (returns.requires || returns.optional) === 'Binary') {\n      return this[p.api].blob('channels/get', payload);\n    }\n\n    // We request getter value by unique getter id, so we can have only\n    // results for this getter.\n    return this[p.api].put('channels/get', payload)\n      .then((response) => response[channel.id]);\n  }\n\n  /**\n   * Setups value watcher for the getter matching specified selector.\n   *\n   * @param {string} alias Watcher alias to match getter which value we would\n   * like to watch.\n   * @param {function} handler Function to be called once getter value changes.\n   */\n  watch(alias, handler) {\n    const watcher = this[p.watchers].get(alias);\n    if (!watcher) {\n      throw new Error('Unsupported watcher `${alias}`!');\n    }\n\n    const [selector, processor, wrappedHandlers = new Map()] = watcher;\n    if (wrappedHandlers.size === 0) {\n      watcher.push(wrappedHandlers);\n    }\n\n    let wrappedHandler = wrappedHandlers.get(handler);\n    if (!wrappedHandler) {\n      wrappedHandler = (value) => handler(this[processor](value));\n      wrappedHandlers.set(handler, wrappedHandler);\n    }\n\n    const { id: getterId } = this[p.getFetchChannel](selector);\n    this[p.api].watch(getterId, wrappedHandler);\n  }\n\n  /**\n   * Removes value watcher for the getter matching specified selector.\n   *\n   * @param {string} alias Watcher alias to match getter for which we would like\n   * to remove value watcher.\n   * @param {function} handler Function that was used in corresponding watch\n   * call.\n   */\n  unwatch(alias, handler) {\n    const watcher = this[p.watchers].get(alias);\n    if (!watcher) {\n      throw new Error('Unsupported watcher `${alias}`!');\n    }\n\n    const [selector,, wrappedHandlers] = watcher;\n\n    const wrappedHandler = wrappedHandlers.get(handler);\n    wrappedHandlers.delete(handler);\n\n    const { id: getterId } = this[p.getFetchChannel](selector);\n    this[p.api].unwatch(getterId, wrappedHandler);\n  }\n\n  /**\n   * Returns list of service tags.\n   *\n   * @return {Array<string>}\n   */\n  getTags() {\n    // Return a copy of the set in the form of plain array, to avoid side\n    // modifications.\n    return Array.from(this[p.tags]);\n  }\n\n  /**\n   * Adds specified tag to the service/all its channels tag list.\n   *\n   * @param {string} tag Tag to add.\n   * @return {Promise}\n   */\n  addTag(tag) {\n    if (!tag || typeof tag !== 'string') {\n      throw new Error('Tag should be valid non-empty string.');\n    }\n\n    if (this[p.tags].has(tag)) {\n      return Promise.resolve();\n    }\n\n    this[p.tags].add(tag);\n\n    // For now we mark channels with the specified tag as well, so that tag can\n    // be picked up from the places that don't have access to the service\n    // instance (eg. recipes view).\n    const servicesSelector = { services: { id: this[p.id] }, tags: tag };\n    const channelsSelector = { channels: { service: this[p.id] }, tags: tag };\n\n    return Promise.all([\n      this[p.api].post('services/tags', servicesSelector),\n      this[p.api].post('channels/tags', channelsSelector),\n    ])\n    .catch((error) => {\n      this[p.tags].delete(tag);\n      throw error;\n    });\n  }\n\n  /**\n   * Removes specified tag from the service/all its channels tag list.\n   *\n   * @param {string} tag Tag to remove.\n   * @return {Promise}\n   */\n  removeTag(tag) {\n    if (!tag || typeof tag !== 'string') {\n      throw new Error('Tag should be valid non-empty string.');\n    }\n\n    if (!this[p.tags].has(tag)) {\n      return Promise.resolve();\n    }\n\n    this[p.tags].delete(tag);\n\n    const servicesSelector = { services: { id: this[p.id] }, tags: tag };\n    const channelsSelector = { channels: { service: this[p.id] }, tags: tag };\n\n    return Promise.all([\n      this[p.api].delete('services/tags', servicesSelector),\n      this[p.api].delete('channels/tags', channelsSelector),\n    ])\n    .catch((error) => {\n      this[p.tags].add(tag);\n      throw error;\n    });\n  }\n\n  /**\n   * Method that should be called when service instance is not needed anymore.\n   * Classes that extend BaseService and override this method should always call\n   * super.teardown() method as well.\n   */\n  teardown() {\n    for (const watcher of this[p.watchers].values()) {\n      const [selector,, wrappedHandlers] = watcher;\n\n      // If nobody set up watchers or all watchers has been properly unwatched,\n      // we don't have anything to do here.\n      if (!wrappedHandlers || wrappedHandlers.size === 0) {\n        continue;\n      }\n\n      const { id: getterId } = this[p.getFetchChannel](selector);\n      for (const wrappedHandler of wrappedHandlers.values()) {\n        console.warn(`Forgotten watcher for ${getterId}!`);\n        this[p.api].unwatch(getterId, wrappedHandler);\n      }\n\n      wrappedHandlers.clear();\n    }\n  }\n\n  /**\n   * Returns list of channels that match to specified selector.\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Array<Object>}\n   * @private\n   */\n  [p.getChannels](selector) {\n    if (selector.id) {\n      const channel = this[p.channels][selector.id];\n      return channel ? [channel] : [];\n    }\n\n    if (selector.feature || typeof selector === 'string') {\n      const channelFeature = selector.feature || selector;\n\n      return Object.keys(this[p.channels]).reduce((channels, key) => {\n        const channel = this[p.channels][key];\n\n        if (channel.feature === channelFeature) {\n          channels.push(channel);\n        }\n\n        return channels;\n      }, []);\n    }\n\n    return [];\n  }\n\n  /**\n   * Returns channel that supports fetch operation and matches to specified\n   * selector.\n   *\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Object}\n   * @throws Will throw if there is no channel that corresponds to selector and\n   * supports fetch operation.\n   * @private\n   */\n  [p.getFetchChannel](selector) {\n    const channel = this[p.getChannels](selector).find(\n      (channel) => channel.supports_fetch\n    );\n\n    if (!channel) {\n      throw new Error(\n        `Couldn't find channel that supports \"fetch\" with selector: ${selector}`\n      );\n    }\n\n    return channel;\n  }\n\n  /**\n   * Returns channel that supports send operation and matches to specified\n   * selector.\n   *\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Object}\n   * @throws Will throw if there is no channel that corresponds to selector and\n   * supports send operation.\n   * @private\n   */\n  [p.getSendChannel](selector) {\n    const channel = this[p.getChannels](selector).find(\n      (channel) => channel.supports_send\n    );\n\n    if (!channel) {\n      throw new Error(\n        `Couldn't find channel that supports \"send\" with selector: ${selector}`\n      );\n    }\n\n    return channel;\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'ip-camera';\n\nexport default class IpCameraService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  getLatestImage() {\n    return this.get('camera/x-latest-image');\n  }\n\n  takeSnapshot() {\n    return this.set('camera/store-snapshot')\n      .then(() => this.get('camera/x-latest-image'));\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'light';\n\nexport default class LightService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  isAvailable() {\n    return this.get('device/available')\n      .then((response) => response.OnOff === 'On');\n  }\n\n  isOn() {\n    return this.get('light/is-on')\n      .then((response) => response.OnOff === 'On');\n  }\n\n  /**\n   * Turn the bulb on or off.\n   *\n   * @param {boolean} on Whether to turn it on (true) or off (false).\n   * @return {Promise}\n   */\n  turn(on) {\n    return this.set('light/is-on', on ? 'On' : 'Off');\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'door-lock';\n\nexport default class DoorLockService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  /**\n   * Checks if the lock is locked.\n   *\n   * @return {Promise.<boolean>}\n   */\n  isLocked() {\n    return this.get('door/is-locked')\n      .then((response) => {\n        if (!response) {\n          throw new Error('Door lock status is not available yet!');\n        }\n\n        return response.DoorLocked === 'Locked';\n      });\n  }\n\n  /**\n   * Either locks or unlocks the lock depending on the \"locked\" parameter.\n   *\n   * @param {boolean} locked Boolean value indicating whether we want lock or\n   * unlock the lock.\n   * @return {Promise}\n   */\n  lockUnlock(locked) {\n    return this.set('door/is-locked', locked ? 'Locked': 'Unlocked');\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'motion-sensor';\n\nconst p = Object.freeze({\n  onMotionStateChanged: Symbol('onMotionStateChanged'),\n});\n\n/**\n * Converts motion state value to boolean. Considers unknown state (null) the\n * same as state when motion is not detected.\n *\n * @param {Object} motionState Motion state object.\n * @return {boolean}\n * @private\n */\nconst motionStateToBoolean = function(motionState) {\n  if (!motionState) {\n    return false;\n  }\n\n  return motionState.OpenClosed === 'Open';\n};\n\nexport default class MotionSensorService extends BaseService {\n  constructor(props, api) {\n    super(props, api, undefined, new Map([\n      ['motion', ['door/is-open', p.onMotionStateChanged]],\n    ]));\n\n    Object.freeze(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  /**\n   * Returns motion sensor state.\n   *\n   * @return {Promise.<boolean>}\n   */\n  isMotionDetected() {\n    return this.get('door/is-open').then(motionStateToBoolean);\n  }\n\n  /**\n   * Function that is called whenever motion state changes. It is intended to\n   * convert raw getter value into simple boolean.\n   *\n   * @param {Object} motionState State that indicates whether motion detected\n   * or not.\n   * @return {boolean}\n   * @private\n   */\n  [p.onMotionStateChanged](motionState) {\n    return motionStateToBoolean(motionState);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\nimport BaseService from './services/base';\nimport IpCameraService from './services/ip-camera';\nimport LightService from './services/light';\nimport DoorLockService from './services/door-lock';\nimport MotionSensorService from './services/motion-sensor';\n\nconst p = Object.freeze({\n  api: Symbol('api'),\n  settings: Symbol('settings'),\n  db: Symbol('db'),\n  cache: Symbol('services'),\n  pollingTimer: Symbol('pollingTimer'),\n\n  // Private methods.\n  getServiceInstance: Symbol('getServiceInstance'),\n  hasChannelWithFeature: Symbol('hasChannelWithFeature'),\n  getCache: Symbol('getCache'),\n});\n\n/**\n * Compare 2 objects. Returns true if all properties of object A have the same\n * value in object B. Extraneous properties in object B are ignored.\n * Properties order is not important.\n *\n * @param {Object} objectA\n * @param {Object} objectB\n * @return {boolean}\n */\nconst isSimilar = (objectA, objectB) => {\n  const keysA = Object.keys(objectA);\n  const keysB = Object.keys(objectB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  return !keysA.some((keyA) => {\n    const valueA = objectA[keyA];\n    const valueB = objectB[keyA];\n\n    const typeA = typeof valueA;\n\n    if (typeA !== typeof valueB) {\n      return true;\n    }\n\n    if (typeA !== 'object' || valueA === null || valueB === null) {\n      return valueA !== valueB;\n    }\n\n    if (Array.isArray(valueA)) {\n      // We don't sort arrays here since changed order likely means that array\n      // has changed.\n      return valueA.length !== valueB.length ||\n        valueA.some((itemA, index) => itemA !== valueB[index]);\n    }\n\n    return !isSimilar(valueA, valueB);\n  });\n};\n\nexport default class Services extends EventDispatcher {\n  constructor(db, api, settings) {\n    super(['services-changed', 'service-changed']);\n\n    this[p.db] = db;\n    this[p.api] = api;\n    this[p.settings] = settings;\n\n    this[p.cache] = null;\n    this[p.pollingTimer] = new SequentialTimer(\n      this[p.settings].servicePollingInterval\n    );\n\n    Object.seal(this);\n  }\n\n  /**\n   * Retrieves the list of the services available. Relies on IndexedDB and\n   * in-memory cache.\n   *\n   * @return {Promise<Array<BaseService>>} A promise that resolves with an\n   * array of objects.\n   */\n  getAll() {\n    return this[p.getCache]().then((cache) => Array.from(cache.values()));\n  }\n\n  /**\n   * Gets service by id from in-memory cache.\n   * @todo If service doesn't exist in the DB, fetch it from the box.\n   *\n   * @param {string} id Id of the service we retrieve.\n   * @return {Promise<BaseService>}\n   */\n  get(id) {\n    return this[p.getCache]().then((cache) => cache.get(id));\n  }\n\n  /**\n   * Starts or stops polling.\n   *\n   * @param {boolean} pollingEnabled Flag that indicates whether polling should\n   * be started or stopped.\n   */\n  togglePolling(pollingEnabled) {\n    if (pollingEnabled === this[p.pollingTimer].started) {\n      return;\n    }\n\n    if (pollingEnabled) {\n      this[p.pollingTimer].start(this.sync.bind(this));\n    } else {\n      this[p.pollingTimer].stop();\n    }\n  }\n\n  /**\n   * Tries to sync local service list with the actual remote one and emits\n   * appropriate events.\n   *\n   * @return {Promise}\n   */\n  sync() {\n    return Promise.all([\n      this[p.api].get('services'),\n      this[p.db].getServices(),\n      this[p.getCache](),\n    ])\n    .then(([fetchedServices, storedServices, cache]) => {\n      let servicesToAddCount = 0;\n      fetchedServices.forEach((fetchedService) => {\n        const storedService = storedServices.find(\n          (storedService) => storedService.id === fetchedService.id\n        );\n\n        const isExistingService = !!storedService;\n\n        if (isExistingService && isSimilar(fetchedService, storedService)) {\n          return;\n        }\n\n        // Populate the db with the latest service.\n        this[p.db].setService(fetchedService);\n\n        const service = this[p.getServiceInstance](fetchedService);\n        cache.set(service.id, service);\n\n        if (isExistingService) {\n          this.emit('service-changed', service);\n        } else {\n          servicesToAddCount++;\n        }\n      });\n\n      const servicesToRemoveCount = storedServices.length +\n        servicesToAddCount - fetchedServices.length;\n      if (servicesToRemoveCount > 0) {\n        storedServices.forEach((storedService) => {\n          const fetchedService = fetchedServices.find(\n            (fetchedService) => fetchedService.id === storedService.id\n          );\n\n          if (!fetchedService) {\n            this[p.db].deleteService(storedService);\n\n            // We should teardown service instance and remove it from the cache.\n            const cachedService = cache.get(storedService.id);\n            cachedService.teardown();\n            cache.delete(cachedService.id);\n          }\n        });\n      }\n\n      if (servicesToAddCount > 0 || servicesToRemoveCount > 0) {\n        this.emit('services-changed');\n      }\n    });\n  }\n\n  /**\n   * Returns in-memory service cache. When cache is not initialized we fill it\n   * in with the content of local IndexedDB.\n   *\n   * @return {Promise<Map<string, BaseService>>}\n   * @private\n   */\n  [p.getCache]() {\n    if (this[p.cache]) {\n      return this[p.cache];\n    }\n\n    return this[p.cache] = this[p.db].getServices()\n      .catch((err) => {\n        console.error('Could not load services from the local DB: %o', err);\n        // Don't consider IndexedDB failure as critical error.\n        return [];\n      })\n      .then((dbServices) => {\n        const cache = new Map();\n\n        dbServices.forEach((dbService) => {\n          cache.set(dbService.id, this[p.getServiceInstance](dbService));\n        });\n\n        return cache;\n      });\n  }\n\n  /**\n   * Creates specific service instance using raw data returned from server. If\n   * there is no specific service class provided, BaseService class is used.\n   *\n   * @param {Object} data Service raw data.\n   * @return {Object}\n   * @private\n   */\n  [p.getServiceInstance](data) {\n    switch (data.adapter) {\n      case 'ip-camera@link.mozilla.org':\n        return new IpCameraService(data, this[p.api]);\n\n      case 'philips_hue@link.mozilla.org':\n        return new LightService(data, this[p.api]);\n\n      case 'OpenZwave Adapter':\n        if (this[p.hasChannelWithFeature](data.channels, 'door/is-locked')) {\n          return new DoorLockService(data, this[p.api]);\n        }\n\n        if (this[p.hasChannelWithFeature](data.channels, 'door/is-open')) {\n          return new MotionSensorService(data, this[p.api]);\n        }\n\n        return new BaseService(data, this[p.api]);\n\n      default:\n        return new BaseService(data, this[p.api]);\n    }\n  }\n\n  /**\n   * Detects if channel list contains channel with specified feature.\n   *\n   * @param {Array<Object>} channels List of the channels to look through.\n   * @param {string} feature Feature that channel we're looking for should have.\n   * @return {boolean}\n   * @private\n   */\n  [p.hasChannelWithFeature](channels, feature) {\n    return Object.keys(channels).some(\n      (key) => channels[key].feature === feature\n    );\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\n\nconst p = Object.freeze({\n  settings: Symbol('settings'),\n  net: Symbol('net'),\n\n  watchTimer: Symbol('watchTimer'),\n  watchEventBus: Symbol('watchEventBus'),\n  watchGetters: Symbol('watchGetters'),\n\n  // Private methods.\n  getURL: Symbol('getURL'),\n  onceOnline: Symbol('onceOnline'),\n  onceAuthenticated: Symbol('onceAuthenticated'),\n  onceDocumentVisible: Symbol('onceDocumentVisible'),\n  onceReady: Symbol('onceReady'),\n  fetchGetterValues: Symbol('fetchGetterValues'),\n  updateGetterValue: Symbol('updateGetterValue'),\n});\n\n/**\n * Instance of the API class is intended to abstract consumer from the API\n * specific details (e.g. API base URL and version). It also tracks\n * availability of the network, API host and whether correct user session is\n * established. If any of this conditions is not met all API requests are\n * blocked until it's possible to perform them, so consumer doesn't have to\n * care about these additional checks.\n */\nexport default class API {\n  constructor(net, settings) {\n    this[p.net] = net;\n    this[p.settings] = settings;\n\n    this[p.watchTimer] = new SequentialTimer(this[p.settings].watchInterval);\n    this[p.watchEventBus] = new EventDispatcher();\n    this[p.watchGetters] = new Map();\n\n    this[p.fetchGetterValues] = this[p.fetchGetterValues].bind(this);\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Performs HTTP 'GET' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @return {Promise}\n   */\n  get(path) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path)));\n  }\n\n  /**\n   * Performs HTTP 'POST' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'POST' body.\n   * @return {Promise}\n   */\n  post(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'POST', body));\n  }\n\n  /**\n   * Performs HTTP 'PUT' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'PUT' body.\n   * @return {Promise}\n   */\n  put(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'PUT', body));\n  }\n\n  /**\n   * Performs HTTP 'DELETE' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'DELETE' body.\n   * @return {Promise}\n   */\n  delete(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'DELETE', body));\n  }\n\n  /**\n   * Performs either HTTP 'GET' or 'PUT' (if body parameter is specified) API\n   * request and accepts Blob as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'PUT' body.\n   * @param {string=} accept Mime type of the Blob we expect as a response\n   * (default is image/jpeg).\n   * @return {Promise}\n   */\n  blob(path, body, accept = 'image/jpeg') {\n    return this[p.onceReady]()\n      .then(() => {\n        if (body) {\n          return this[p.net].fetchBlob(\n            this[p.getURL](path), accept, 'PUT', body\n          );\n        }\n\n        return this[p.net].fetchBlob(this[p.getURL](path), accept);\n      });\n  }\n\n  /**\n   * Registers watcher for the getter with specified id.\n   *\n   * @todo We may need to accept getter's \"supports_fetch\" property in the\n   * future too, to validate getter value type.\n   *\n   * @param {string} getterId Id of the getter we'd like to watch.\n   * @param {function} handler Handler to be executed once watched value is\n   * changed.\n   */\n  watch(getterId, handler) {\n    this[p.watchEventBus].on(getterId, handler);\n\n    if (this[p.watchGetters].has(getterId)) {\n      return;\n    }\n\n    this[p.watchGetters].set(getterId, {\n      id: getterId,\n      // Using null as initial value, some getters can return null when value\n      // is not yet available, so it perfectly fits our case.\n      value: null,\n    });\n\n    // We automatically start watching if at least one getter is requested to\n    // be watched.\n    if (!this[p.watchTimer].started) {\n      this[p.watchTimer].start(this[p.fetchGetterValues]);\n    }\n  }\n\n  /**\n   * Unregisters watcher for the getter with specified id.\n   *\n   * @param {string} getterId Id of the getter we'd like to not watch anymore.\n   * @param {function} handler Handler function that has been used with \"watch\"\n   * previously.\n   */\n  unwatch(getterId, handler) {\n    if (!this[p.watchGetters].has(getterId)) {\n      console.warn('Getter with id \"%s\" is not watched.', getterId);\n      return;\n    }\n\n    this[p.watchEventBus].off(getterId, handler);\n\n    // If there is no more listeners, we should not watch this getter anymore.\n    if (!this[p.watchEventBus].hasListeners(getterId)) {\n      this[p.watchGetters].delete(getterId);\n    }\n\n    // If no more getters are watched let's stop watching.\n    if (this[p.watchGetters].size === 0) {\n      this[p.watchTimer].stop();\n    }\n  }\n\n  /**\n   * Creates a fully qualified API URL based on predefined base origin, API\n   * version and specified resource path.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path and version.\n   * @return {string}\n   * @private\n   */\n  [p.getURL](path) {\n    if (!path || typeof path !== 'string') {\n      throw new Error('Path should be valid non-empty string.');\n    }\n\n    return `${this[p.net].origin}/api/v${this[p.settings].apiVersion}/${path}`;\n  }\n\n  /**\n   * Returns promise that is resolved once API is ready to use (API host is\n   * discovered and online, authenticated user session is established and\n   * document is visible).\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceReady]() {\n    return Promise.all([\n      this[p.onceOnline](),\n      this[p.onceAuthenticated](),\n      this[p.onceDocumentVisible](),\n    ]);\n  }\n\n  /**\n   * Returns promise that is resolved once API host is discovered and online.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceOnline]() {\n    const net = this[p.net];\n    if (net.online) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => net.once('online', () => resolve()));\n  }\n\n  /**\n   * Returns promise that is resolved once authenticated user session is\n   * established.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceAuthenticated]() {\n    const settings = this[p.settings];\n    if (settings.session) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => settings.once('session', () => resolve()));\n  }\n\n  /**\n   * Returns promise that is resolved once document becomes visible.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceDocumentVisible]() {\n    if (!document.hidden) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      document.addEventListener('visibilitychange',\n      function onVisibilityChange() {\n        if (!document.hidden) {\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetches values for the set of getters.\n   *\n   * @return {Promise}\n   * @private\n   */\n  [p.fetchGetterValues]() {\n    // It may happen that all watchers have been unregistered in the meantime,\n    // so let's return early in this case.\n    if (this[p.watchGetters].size === 0) {\n      return Promise.resolve();\n    }\n\n    const selectors = Array.from(this[p.watchGetters].values()).map(\n      ({ id }) => ({ id })\n    );\n\n    return this.put('channels/get', selectors)\n      .then((response) => {\n        Object.keys(response).forEach((key) => {\n          const getter = this[p.watchGetters].get(key);\n          if (!getter) {\n            return;\n          }\n\n          this[p.updateGetterValue](getter, response[key]);\n        });\n      });\n  }\n\n  /**\n   * Updates getter value if needed. If value has changed, appropriate event is\n   * fired.\n   *\n   * @param {{ id: string, value: Object }} getter Getter to update value for.\n   * @param {Object} getterValue Getter value returned from the server.\n   *\n   * @private\n   */\n  [p.updateGetterValue](getter, getterValue) {\n    let valueChanged = false;\n\n    if (!getterValue || !getter.value) {\n      valueChanged = getterValue !== getter.value;\n    } else {\n      const [valueType] = Object.keys(getterValue);\n      if (valueType === 'Error') {\n        console.error(\n          'Failed to retrieve value for getter (%s): %o',\n          getter.id,\n          getterValue[valueType]\n        );\n\n        return;\n      }\n\n      const newValue = getterValue[valueType];\n      const oldValue = getter.value[valueType];\n\n      if (newValue && oldValue && typeof newValue === 'object') {\n        // @todo If value is a non-null object, we use their JSON representation\n        // to compare values. It's not performant and not reliable at all, but\n        // this OK until we have such values, once we support them we should\n        // have dedicated utility function for deep comparing objects.\n        valueChanged = JSON.stringify(newValue) !== JSON.stringify(oldValue);\n      } else {\n        valueChanged = newValue !== oldValue;\n      }\n    }\n\n    if (valueChanged) {\n      getter.value = Object.freeze(getterValue);\n      this[p.watchEventBus].emit(getter.id, getter.value);\n    }\n  }\n}\n","/* global URLSearchParams */\n\n'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\n\nimport Settings from './settings';\nimport Db from './db';\nimport Network from './network';\nimport Recipes from './recipes';\nimport WebPush from './webpush';\nimport Services from './services';\nimport API from './api';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  settings: Symbol('settings'),\n  db: Symbol('db'),\n  net: Symbol('net'),\n  boxes: Symbol('boxes'),\n  webPush: Symbol('webPush'),\n  api: Symbol('api'),\n});\n\nexport default class Foxbox extends EventDispatcher {\n  constructor({ settings, db, net } = {}) {\n    super(['push-message', 'online', 'discovery']);\n\n    // Private properties.\n    this[p.settings] = settings || new Settings();\n    this[p.db] = db || new Db();\n    this[p.net] = net || new Network(this[p.settings]);\n    this[p.boxes] = Object.freeze([]);\n    this[p.api] = new API(this[p.net], this[p.settings]);\n    this[p.webPush] = new WebPush(this[p.api], this[p.settings]);\n\n    this.services = new Services(this[p.db], this[p.api], this[p.settings]);\n    this.recipes = new Recipes(this[p.api]);\n\n    Object.seal(this);\n  }\n\n  init() {\n    window.foxbox = this;\n\n    this[p.net].on('online', (online) => this.emit('online', online));\n\n    this[p.webPush].on('message', (msg) => this.emit('push-message', msg));\n\n    // No need to block the UI on the discovery process.\n    // Once we discover a box we can connect to, we will start\n    // polling and triggering box-online events with a boolean\n    // indicating if we have access to box or not.\n    this._initDiscovery()\n      .then(() => this[p.net].init());\n\n    return this._initUserSession()\n      // The DB is only initialised if there's no redirection to the box.\n      .then(() => this[p.db].init());\n  }\n\n  /**\n   * Clear all data/settings stored on the browser. Use with caution.\n   *\n   * @param {boolean} ignoreServiceWorker\n   * @return {Promise}\n   */\n  clear(ignoreServiceWorker) {\n    const promises = [this[p.settings].clear(), this[p.db].clear()];\n    if (!navigator.serviceWorker) {\n      return Promise.all(promises);\n    }\n\n    if (!ignoreServiceWorker) {\n      promises.push(navigator.serviceWorker.ready\n        .then((registration) => registration.unregister()));\n    }\n\n    return Promise.all(promises);\n  }\n\n  get online() {\n    return this[p.net].online;\n  }\n\n  get client() {\n    return this[p.settings].client;\n  }\n\n  get boxes() {\n    return this[p.boxes];\n  }\n\n  /**\n   * Get the URL of the box using the registration server.\n   * If it fails, we fallback to the previously set hostname.\n   * It there isn't, we schedule a retry.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _initDiscovery() {\n    // For development purposes if you want to skip the\n    // discovery phase set the 'foxbox-skipDiscovery' variable to\n    // 'true'.\n    if (this[p.settings].skipDiscovery) {\n      return Promise.resolve();\n    }\n\n    return this[p.net].fetchJSON(this[p.settings].registrationService)\n      .then((boxes) => {\n        if (!Array.isArray(boxes)) {\n          console.warn('Got unexpected response from registry server', boxes);\n          return;\n        }\n\n        // We filter out boxes registered more than 2 minutes ago.\n        const now = Math.floor(Date.now() / 1000) - 60 * 2;\n        this[p.boxes] = Object.freeze(\n          boxes\n            .filter((box) => box.timestamp - now >= 0)\n            .map((box) => {\n              // NOTE(sgiles): There is consideration to allow\n              // only \"local_origin\" and \"tunnel_origin\", removing the\n              // need to parse message - this merges the relevant message\n              // fields into the main object\n              const { local_origin, tunnel_origin } = JSON.parse(box.message);\n              const client = box.client;\n\n              return Object.freeze({ local_origin, tunnel_origin, client });\n            })\n        );\n\n        // Fire event every time registration server returns a valid response.\n        // @todo We should improve this logic and check if boxes list has\n        // actually changed and if so only then override internal box list and\n        // fire event.\n        this.emit('discovery');\n\n        // If the registration server didn't give us any info and\n        // we have no record of previous registrations, we schedule\n        // a retry.\n        if (!this[p.boxes].length &&\n            !this[p.settings].localOrigin &&\n            !this[p.settings].tunnelOrigin) {\n          throw new Error('Registration service did not return any boxes.');\n        }\n\n        if (!this[p.settings].configured && this[p.boxes].length === 1) {\n          this.selectBox();\n        }\n      })\n      .catch((error) => {\n        if (this[p.settings].localOrigin || this[p.settings].tunnelOrigin) {\n          // Default to a previously stored box registration.\n          return;\n        }\n\n        // If there's no previously stored box registration, we schedule a\n        // retry.\n        console.warn('Retrying box discovery... Reason is %o', error);\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            this._initDiscovery().then(resolve, resolve);\n          }, 1000);\n        });\n      });\n  }\n\n  /**\n   * Change the currently selected box.\n   *\n   * @param {number} index The index of the box in the boxes array.\n   */\n  selectBox(index = 0) {\n    if (!this[p.boxes].length) {\n      this[p.settings].configured = false;\n      console.error('No boxes found. Is this app online? Is the box online?');\n\n      return;\n    }\n\n    if (index >= this[p.boxes].length) {\n      this[p.settings].configured = false;\n      console.error('Index out of range.');\n\n      return;\n    }\n\n    const box = this[p.boxes][index];\n\n    this[p.settings].localOrigin = box.local_origin;\n    if (box.tunnel_origin) {\n      this[p.settings].tunnelOrigin = box.tunnel_origin;\n    } else {\n      this[p.settings].tunnelOrigin = '';\n    }\n\n    this[p.settings].client = box.client;\n    this[p.settings].configured = true;\n  }\n\n  /**\n   * Detect a session token in the URL and process it if present.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _initUserSession() {\n    if (this.isLoggedIn) {\n      return Promise.resolve();\n    }\n\n    const url = new URL(location.href);\n    const searchParams = new URLSearchParams(url.search.substring(1));\n    if (!searchParams.has('session_token')) {\n      return Promise.resolve();\n    }\n\n    // There is a session token in the URL, let's remember it.\n    // @todo Find a better way to handle URL escape.\n    this[p.settings].session = searchParams.get('session_token')\n      .replace(/ /g, '+');\n\n    // Remove the session param from the current location.\n    searchParams.delete('session_token');\n    url.search = searchParams;\n    location.replace(url.href);\n\n    // Returning rejected promise here the promise chain.\n    return Promise.reject();\n  }\n\n  get isLoggedIn() {\n    return !!this[p.settings].session;\n  }\n\n  /**\n   * Redirect the user to the box to get authenticated if she isn't already.\n   */\n  login() {\n    if (this.isLoggedIn) {\n      return;\n    }\n\n    const redirectUrl = encodeURIComponent(location);\n    location.replace(`${this[p.net].origin}/?redirect_url=${redirectUrl}`);\n  }\n\n  /**\n   * Log out the user.\n   */\n  logout() {\n    this[p.settings].session = null;\n  }\n\n  /**\n   * Ask the user for accepting push notifications from the box.\n   * This method will be call each time that we log in, but will\n   * stop the execution if we already have the push subscription\n   * information.\n   *\n   * @param {boolean} resubscribe Parameter used for testing\n   * purposes, and follow the whole subscription process even if\n   * we have push subscription information.\n   * @return {Promise}\n   */\n  subscribeToNotifications(resubscribe = false) {\n    return this[p.webPush].subscribeToNotifications(resubscribe);\n  }\n}\n","import BaseController from './base';\nimport UsersController from './users';\nimport ServicesController from './services';\nimport ServiceController from './service';\nimport ServiceTagsController from './service-tags';\nimport ThemesController from './themes';\nimport DevController from './dev';\n\nimport Foxbox from '../lib/foxbox/foxbox';\n\nconst p = Object.freeze({\n  controllers: Symbol('controllers'),\n  onHashChanged: Symbol('onHashChanged'),\n});\n\nexport default class MainController extends BaseController {\n  constructor() {\n    super();\n\n    const foxbox = this.foxbox = new Foxbox();\n    const mountNode = document.querySelector('.app-view-container');\n    const options = { foxbox, mountNode };\n\n    const usersController = new UsersController(options);\n    const themesController = new ThemesController(options);\n\n    this[p.controllers] = {\n      '': usersController,\n      'users/(.+)': usersController,\n      'services': new ServicesController(options),\n      'services/(.+)/tags': new ServiceTagsController(options),\n      'services/(.+)': new ServiceController(options),\n      'themes': themesController,\n      'themes/(.+)': themesController,\n      'dev/(.+)/(.+)': new DevController(options),\n    };\n\n    window.addEventListener('hashchange', this[p.onHashChanged].bind(this));\n  }\n\n  main() {\n    this.foxbox.init()\n      .then(() => {\n        if (this.foxbox.isLoggedIn) {\n          this.foxbox.subscribeToNotifications();\n\n          // Let's schedule service list sync as soon as possible.\n          this.foxbox.services.sync();\n\n          if (location.hash === '') {\n            location.hash = '#services';\n          }\n\n          this.foxbox.on('push-message', (msg) => {\n            if (msg.action) {\n              location.hash = msg.action;\n            }\n          });\n        } else {\n          location.hash = '#users/login';\n        }\n\n        this[p.onHashChanged]();\n      });\n  }\n\n  /**\n   * Handles hash change event and routes to the right controller.\n   *\n   * @private\n   */\n  [p.onHashChanged]() {\n    const route = window.location.hash.slice(1);\n\n    for (const routeName of Object.keys(this[p.controllers])) {\n      const match = route.match(new RegExp(`^${routeName}$`));\n      if (match) {\n        this[p.controllers][routeName].main(...match.slice(1));\n        break;\n      }\n    }\n  }\n}\n","import MainController from './controllers/main';\n\nconst mainController = new MainController();\nmainController.main();\n"],"names":["jsx","REACT_ELEMENT_TYPE","Symbol","type","props","key","children","defaultProps","childrenLength","arguments","length","propName","childArray","Array","i","$$typeof","undefined","ref","_owner","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","descriptor","enumerable","configurable","writable","Object","defineProperty","protoProps","staticProps","prototype","inherits","subClass","superClass","create","constructor","value","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","iterator","next","done","push","err","isArray","toConsumableArray","arr2","from","BaseController","properties","assign","this","main","Error","NavigationMenu","_React$Component","foxbox","shouldComponentUpdate","handleOnClick","logout","render","route","location","hash","substr","split","shift","menuNodes","map","menu","className","id","label","bind","React","Component","BaseView","renderHeader","title","cssClass","renderFooter","renderBody","UserLogin","_BaseView","state","boxes","online","onBoxOnline","_this","onBoxDiscovery","onSelectChange","onFormSubmit","componentDidMount","on","componentWillUnmount","off","evt","selectedBox","selectedIndex","setState","selectBox","preventDefault","login","loginEnabled","boxNodes","optionNodes","box","index","client","_this2","ALLOWED_ACTIONS","DEFAULT_ACTION","UsersController","action","includes","error","createElement","mountNode","ServicesListItem","service","onMotion","isAvailable","then","available","console","isOn","isMotionDetected","watch","isLocked","locked","unwatch","handleLightOnChange","checked","turn","onDoorLockUnlock","lockUnlock","motionDetected","getBulbColour","hue","sat","val","h","s","Math","round","l","renderLightService","isConnected","serviceType","icon","model","serviceName","getServiceName","serviceNameNode","background","renderDoorLock","renderMotionSensor","motionSensorNameNode","motionSensorClassName","renderGenericService","getTags","join","name","ServicesList","knownServices","services","filter","serviceNodes","Services","updateServiceList","updateServiceState","togglePolling","getAll","serviceId","findIndex","ServicesListView","ServicesController","CameraService","takeSnapshot","image","previousSnapshot","refs","snapshotPreview","src","newState","URL","createObjectURL","hasPreviousSnapshot","revokeObjectURL","cameraControlsClass","hasPreview","LightService","onServiceStateChanged","Service","get","CameraServiceView","LightServiceView","DefaultServiceView","propTypes","PropTypes","object","isRequired","string","ServiceController","TagList","tagNodes","tags","tag","onRemoveTag","ServiceTags","onAddTag","prompt","trim","addTag","removeTag","ServiceTagsController","ServiceTagsView","ThemesListItem","theme","enabled","handleOnChange","handleOnDelete","recipes","toggle","remove","update","Themes","themes","themeItems","ThemesListItemView","_this3","ThemesNew","updateServices","onGetterSelected","onGetterValueSelected","onSetterSelected","onSetterValueSelected","onSaveRecipe","all","getGetters","getSetters","getters","setters","selectedGetterIndex","Number","selectedGetterValueIndex","selectedSetterIndex","selectedSetterValueIndex","getter","getterValue","options","setter","setterValue","add","log","actionButtonClassName","headerClassName","renderGetterSelector","renderGetterValueSelector","renderSetterSelector","renderSetterValueSelector","getChannelName","option","_this4","channel","ThemesController","CameraLatestImage","getLatestImage","flexGrow","DevController","path","args","CameraLatestImageView","assertValidEventName","eventName","assertValidHandler","handler","assertAllowedEventName","allowedEvents","indexOf","p","freeze","EventDispatcher","listeners","Map","handlers","Set","set","once","parameters","size","offAll","clear","emit","forEach","hasListeners","has","PREFIX","API_VERSION","QUERY_STRING_AUTH_TOKEN_NAME","UPPER_CASE_REGEX","settings","Settings","storage","localStorage","_EventDispatcher","values","keys","settingName","setting","settingStringValue","getItem","stringToSettingTypedValue","addEventListener","onStorage","seal","Promise","resolve","updateSetting","getDefaultSettingValue","newValue","currentValue","setItem","removeItem","replace","part","toLowerCase","stringValue","defaultValue","startsWith","substring","find","warn","CONFIGURED","LOCAL_ORIGIN","origin","TUNNEL_ORIGIN","CLIENT","String","SESSION","SKIP_DISCOVERY","SERVICE_POLLING_ENABLED","PUSH_ENDPOINT","PUSH_PUB_KEY","PUSH_AUTH","REGISTRATION_SERVICE","SERVICE_POLLING_INTERVAL","ONLINE_CHECKING_INTERVAL","ONLINE_CHECKING_LONG_INTERVAL","WATCH_INTERVAL","Defer","promise","reject","DB_NAME","DB_VERSION","DB_SERVICE_STORE","Db","db","initializationStarted","init","initializationPromise","req","indexedDB","open","onupgradeneeded","upgradeSchema","onsuccess","result","onerror","close","deleteDatabase","onblocked","getServices","getService","getById","setService","data","deleteService","clearServices","clearDb","fromVersion","oldVersion","store","createObjectStore","keyPath","createIndex","unique","txn","transaction","results","oncomplete","objectStore","openCursor","cursor","put","SequentialTimer","interval","started","nextTickHandle","onTick","start","scheduleTick","stop","setTimeout","BoxLink","ping","lastSeenOnline","pingTimer","POSITIVE_INFINITY","seenOnline","Date","now","enableAutoPing","disableAutoPing","force","seenOnlineRecently","document","hidden","fetch","cache","res","ok","isOnline","Network","localLink","tunnelLink","linkPingInterval","pingLinks","onLinkOnlineChange","onLinkOriginChange","navigator","connection","onlineCheckingLongInterval","onlineCheckingInterval","fetchJSON","url","method","body","response","json","fetchBlob","blobType","blob","accept","toUpperCase","Accept","headers","session","Authorization","JSON","stringify","status","requestOrigin","updateLink","symbol","link","localOrigin","tunnelOrigin","onlineStatus","Recipe","source","Recipes","api","post","channels","feature","reduce","rule","channelId","getSource","selectors","enabledSelectors","sourceSelectors","statuses","sources","statusResponse","sourceResponse","OnOff","parse","supportedFeatures","supports_fetch","Geq","Duration","Eq","OpenClosed","DoorLocked","adapter","supports_send","Unit","execute","recipe","textValue","createDemoRecipes","clockGetter","lightsSetter","conditions","concat","createDoorLockDemoRecipe","doorLockGetter","doorLockSetter","WebPush","subscribeToNotifications","resubscribe","serviceWorker","listenForMessages","pushEndpoint","pushPubKey","pushAuth","ready","reg","pushManager","subscribe","userVisibleOnly","subscription","endpoint","getKey","auth","btoa","fromCharCode","apply","Uint8Array","pushConfigurationMsg","pushResourcesMsg","Json","resources","Notification","permission","msg","TYPE","BaseService","watchers","manufacturer","product_name","selector","getSendChannel","accepts","payload","requires","optional","getFetchChannel","returns","alias","watcher","processor","wrappedHandlers","wrappedHandler","getterId","servicesSelector","channelsSelector","teardown","getChannels","channelFeature","_this5","IpCameraService","_BaseService","DoorLockService","motionStateToBoolean","motionState","MotionSensorService","onMotionStateChanged","isSimilar","objectA","objectB","keysA","keysB","some","keyA","valueA","valueB","typeA","itemA","pollingTimer","servicePollingInterval","getCache","pollingEnabled","sync","fetchedServices","storedServices","servicesToAddCount","fetchedService","storedService","isExistingService","getServiceInstance","servicesToRemoveCount","cachedService","dbServices","dbService","hasChannelWithFeature","API","net","watchTimer","watchInterval","watchEventBus","watchGetters","fetchGetterValues","onceReady","getURL","apiVersion","onceOnline","onceAuthenticated","onceDocumentVisible","onVisibilityChange","removeEventListener","_this6","updateGetterValue","valueChanged","valueType","oldValue","Foxbox","webPush","_initDiscovery","_initUserSession","ignoreServiceWorker","promises","registration","unregister","skipDiscovery","registrationService","floor","timestamp","message","local_origin","tunnel_origin","configured","isLoggedIn","href","searchParams","URLSearchParams","search","redirectUrl","encodeURIComponent","MainController","_BaseController","querySelector","usersController","themesController","controllers","onHashChanged","window","slice","routeName","match","RegExp","mainController"],"mappings":"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","sourceRoot":"/source/"}